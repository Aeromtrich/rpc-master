# Yu-RPC-Core 全局配置机制详解

## 概述

Yu-RPC-Core 框架采用了一套完整的全局配置管理机制，通过分层配置类、统一配置加载、单例模式持有者等设计，实现了灵活、线程安全、易扩展的配置管理方案。

## 1. 配置类设计（分层结构）

### 1.1 顶层全局配置类 - RpcConfig

**位置**: `yu-rpc-core/src/main/java/com/yupi/yurpc/config/RpcConfig.java`

```java
@Data
public class RpcConfig {
    /**
     * 名称
     */
    private String name = "yu-rpc";

    /**
     * 版本号
     */
    private String version = "1.0";

    /**
     * 服务器主机名
     */
    private String serverHost = "localhost";

    /**
     * 服务器端口号
     */
    private Integer serverPort = 8080;

    /**
     * 序列化器
     */
    private String serializer = SerializerKeys.JDK;

    /**
     * 负载均衡器
     */
    private String loadBalancer = LoadBalancerKeys.ROUND_ROBIN;

    /**
     * 重试策略
     */
    private String retryStrategy = RetryStrategyKeys.NO;

    /**
     * 容错策略
     */
    private String tolerantStrategy = TolerantStrategyKeys.FAIL_FAST;

    /**
     * 模拟调用
     */
    private boolean mock = false;

    /**
     * 注册中心配置
     */
    private RegistryConfig registryConfig = new RegistryConfig();
}
```

**设计特点**:
- 所有字段都有合理的默认值，降低使用门槛
- 使用 Lombok `@Data` 注解自动生成 getter/setter
- 包含框架核心配置：网络、序列化、负载均衡、容错等
- 嵌套 `RegistryConfig` 实现配置分层

### 1.2 注册中心配置类 - RegistryConfig

**位置**: `yu-rpc-core/src/main/java/com/yupi/yurpc/config/RegistryConfig.java`

```java
@Data
public class RegistryConfig {
    /**
     * 注册中心类别
     */
    private String registry = RegistryKeys.ETCD;

    /**
     * 注册中心地址
     */
    private String address = "http://localhost:2380";

    /**
     * 用户名
     */
    private String username;

    /**
     * 密码
     */
    private String password;

    /**
     * 超时时间（单位毫秒）
     */
    private Long timeout = 10000L;
}
```

**设计特点**:
- 独立的注册中心配置类，职责单一
- 支持多种注册中心类型（Etcd、ZooKeeper）
- 支持认证配置（用户名、密码）
- 默认超时时间 10 秒

## 2. 配置加载机制 - ConfigUtils

**位置**: `yu-rpc-core/src/main/java/com/yupi/yurpc/utils/ConfigUtils.java`

### 2.1 核心方法

```java
public class ConfigUtils {
    /**
     * 加载配置对象
     *
     * @param tClass 目标 Bean 的 Class 对象（例如 RpcConfig.class）
     * @param prefix 配置前缀（例如 "rpc"）
     * @param <T>
     * @return
     */
    public static <T> T loadConfig(Class<T> tClass, String prefix) {
        return loadConfig(tClass, prefix, "");
    }

    /**
     * 加载配置对象，支持区分环境
     *
     * @param tClass      目标类
     * @param prefix      配置前缀
     * @param environment 环境标识（dev、prod 等）
     * @param <T>
     * @return
     */
    public static <T> T loadConfig(Class<T> tClass, String prefix, String environment) {
        StringBuilder configFileBuilder = new StringBuilder("application");
        if (StrUtil.isNotBlank(environment)) {
            configFileBuilder.append("-").append(environment);
        }
        configFileBuilder.append(".properties");
        Props props = new Props(configFileBuilder.toString());
        // 将带有指定前缀的配置项转换为 Java 对象
        return props.toBean(tClass, prefix);
    }
}
```

### 2.2 加载流程

1. **构建配置文件名**:
   - 默认: `application.properties`
   - 带环境: `application-{environment}.properties`

2. **读取配置文件**:
   - 使用 Hutool 的 `Props` 类读取 properties 文件
   - 从 classpath 的 resources 目录加载

3. **映射到对象**:
   - 通过 `props.toBean(tClass, prefix)` 方法
   - 自动将带前缀的配置项映射到对象字段
   - 支持嵌套对象映射（如 `rpc.registryConfig.address`）

### 2.3 配置文件格式示例

```properties
# 基础配置
rpc.name=yurpc
rpc.version=2.0
rpc.serverHost=localhost
rpc.serverPort=8080
rpc.mock=false

# 序列化和负载均衡
rpc.serializer=jdk
rpc.loadBalancer=roundRobin

# 重试和容错
rpc.retryStrategy=fixedInterval
rpc.tolerantStrategy=failFast

# 注册中心配置（嵌套配置）
rpc.registryConfig.registry=etcd
rpc.registryConfig.address=http://localhost:2380
rpc.registryConfig.timeout=10000
```

**配置映射规则**:
- `rpc.name` → `RpcConfig.name`
- `rpc.serverPort` → `RpcConfig.serverPort`
- `rpc.registryConfig.registry` → `RpcConfig.registryConfig.registry`

## 3. 全局配置持有者 - RpcApplication

**位置**: `yu-rpc-core/src/main/java/com/yupi/yurpc/RpcApplication.java`

### 3.1 核心设计

```java
@Slf4j
public class RpcApplication {

    /**
     * 全局配置对象（volatile 保证内存可见性）
     */
    private static volatile RpcConfig rpcConfig;

    /**
     * 获取配置（双检锁单例模式）
     *
     * @return 全局配置对象
     */
    public static RpcConfig getRpcConfig() {
        if (rpcConfig == null) {
            synchronized (RpcApplication.class) {
                if (rpcConfig == null) {
                    init();  // 懒加载初始化
                }
            }
        }
        return rpcConfig;
    }
}
```

### 3.2 双检锁单例模式分析

**为什么使用双检锁?**

1. **线程安全**: 多线程环境下保证只初始化一次
2. **懒加载**: 只有在首次使用时才初始化，节省资源
3. **性能优化**: 第一次检查避免不必要的同步开销

**volatile 关键字的作用**:
- 保证内存可见性：一个线程修改后，其他线程立即可见
- 禁止指令重排序：防止对象未完全初始化就被其他线程访问

**执行流程**:
```
线程 A 调用 getRpcConfig()
    ↓
第一次检查: rpcConfig == null? (无锁，快速检查)
    ↓ (是)
获取类锁: synchronized(RpcApplication.class)
    ↓
第二次检查: rpcConfig == null? (防止重复初始化)
    ↓ (是)
执行初始化: init()
    ↓
释放锁，返回 rpcConfig
```

## 4. 初始化流程

### 4.1 默认初始化

```java
/**
 * 默认的初始化
 */
public static void init() {
    RpcConfig newRpcConfig;
    try {
        // 从配置文件中加载配置
        newRpcConfig = ConfigUtils.loadConfig(RpcConfig.class, RpcConstant.DEFAULT_CONFIG_PREFIX);
    } catch (Exception e) {
        // 配置加载失败，使用默认值
        newRpcConfig = new RpcConfig();
    }
    init(newRpcConfig);
}
```

**特点**:
- 尝试从 `application.properties` 加载配置（前缀 `rpc`）
- 加载失败时使用默认值，保证框架可用性
- 降低使用门槛，无配置文件也能运行

### 4.2 自定义配置初始化

```java
/**
 * 框架初始化，支持传入自定义配置
 *
 * @param newRpcConfig 自定义配置对象
 */
public static void init(RpcConfig newRpcConfig) {
    rpcConfig = newRpcConfig;
    log.info("rpc init, config = {}", newRpcConfig.toString());

    // 注册中心初始化
    RegistryConfig registryConfig = rpcConfig.getRegistryConfig();
    Registry registry = RegistryFactory.getInstance(registryConfig.getRegistry());
    registry.init(registryConfig);
    log.info("registry init, config = {}", registryConfig);

    // 创建并注册 Shutdown Hook，JVM 退出时执行操作
    Runtime.getRuntime().addShutdownHook(new Thread(registry::destroy));
}
```

**初始化步骤**:

1. **保存配置**: 将配置对象赋值给静态变量
2. **日志记录**: 记录配置信息，便于调试
3. **注册中心初始化**:
   - 从配置中获取注册中心类型
   - 通过工厂模式创建注册中心实例
   - 调用 `registry.init()` 初始化连接
4. **注册关闭钩子**:
   - JVM 退出时自动调用 `registry.destroy()`
   - 优雅关闭，释放资源（如关闭 Etcd 连接）

### 4.3 配置常量定义

**位置**: `yu-rpc-core/src/main/java/com/yupi/yurpc/constant/RpcConstant.java`

```java
public interface RpcConstant {
    /**
     * 默认配置文件加载前缀
     */
    String DEFAULT_CONFIG_PREFIX = "rpc";

    /**
     * 默认服务版本
     */
    String DEFAULT_SERVICE_VERSION = "1.0";
}
```

## 5. 配置使用示例

### 5.1 在框架各组件中获取配置

```java
// 示例 1: 在服务提供者中获取服务器配置
public class ProviderBootstrap {
    public void start() {
        RpcConfig config = RpcApplication.getRpcConfig();
        String host = config.getServerHost();
        int port = config.getServerPort();

        // 启动 TCP 服务器
        VertxTcpServer server = new VertxTcpServer();
        server.doStart(port);
    }
}

// 示例 2: 在代理类中获取序列化器配置
public class ServiceProxy implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) {
        RpcConfig config = RpcApplication.getRpcConfig();
        String serializerKey = config.getSerializer();

        // 获取序列化器实例
        Serializer serializer = SerializerFactory.getInstance(serializerKey);
        // ...
    }
}

// 示例 3: 在消费者中获取负载均衡配置
public class ConsumerBootstrap {
    public void init() {
        RpcConfig config = RpcApplication.getRpcConfig();
        String loadBalancerKey = config.getLoadBalancer();

        // 获取负载均衡器实例
        LoadBalancer loadBalancer = LoadBalancerFactory.getInstance(loadBalancerKey);
        // ...
    }
}
```

### 5.2 编程式配置

```java
// 方式 1: 使用默认配置
RpcApplication.init();

// 方式 2: 自定义配置
RpcConfig customConfig = new RpcConfig();
customConfig.setName("my-rpc");
customConfig.setServerPort(9090);
customConfig.setSerializer(SerializerKeys.KRYO);

RegistryConfig registryConfig = new RegistryConfig();
registryConfig.setRegistry(RegistryKeys.ZOOKEEPER);
registryConfig.setAddress("localhost:2181");
customConfig.setRegistryConfig(registryConfig);

RpcApplication.init(customConfig);
```

## 6. 设计亮点分析

### 6.1 分层配置结构

**优势**:
- **职责分离**: 顶层 `RpcConfig` 包含框架级配置，`RegistryConfig` 专注注册中心配置
- **易于扩展**: 可以继续添加 `SerializerConfig`、`LoadBalancerConfig` 等子配置
- **配置隔离**: 不同模块的配置互不干扰

**扩展示例**:
```java
public class RpcConfig {
    private RegistryConfig registryConfig = new RegistryConfig();
    private SerializerConfig serializerConfig = new SerializerConfig();  // 可扩展
    private LoadBalancerConfig loadBalancerConfig = new LoadBalancerConfig();  // 可扩展
}
```

### 6.2 双检锁单例模式

**优势**:
- **线程安全**: 多线程环境下保证配置对象唯一性
- **懒加载**: 延迟初始化，节省启动时间和内存
- **高性能**: 初始化后无锁访问，性能接近直接访问

**对比其他单例模式**:

| 模式 | 线程安全 | 懒加载 | 性能 | 实现复杂度 |
|------|---------|--------|------|-----------|
| 饿汉式 | ✓ | ✗ | 高 | 低 |
| 懒汉式（synchronized） | ✓ | ✓ | 低 | 低 |
| 双检锁 | ✓ | ✓ | 高 | 中 |
| 静态内部类 | ✓ | ✓ | 高 | 中 |

### 6.3 默认值 + 配置文件覆盖

**优势**:
- **开箱即用**: 无需配置文件即可运行，降低学习成本
- **灵活配置**: 可通过配置文件覆盖默认值
- **容错性强**: 配置文件加载失败不影响框架启动

**配置优先级**:
```
编程式配置 > 配置文件 > 默认值
```

### 6.4 统一前缀管理

**优势**:
- **避免冲突**: 所有配置使用 `rpc.` 前缀，不会与其他框架冲突
- **易于识别**: 一眼就能看出是 RPC 框架的配置
- **支持嵌套**: `rpc.registryConfig.address` 清晰表达层级关系

**配置命名规范**:
```properties
# 顶层配置: rpc.{字段名}
rpc.name=yurpc
rpc.serverPort=8080

# 嵌套配置: rpc.{对象名}.{字段名}
rpc.registryConfig.registry=etcd
rpc.registryConfig.address=http://localhost:2380
```

### 6.5 环境隔离支持

**优势**:
- **多环境部署**: 开发、测试、生产环境使用不同配置
- **配置管理**: 配置文件与代码分离，便于维护
- **安全性**: 敏感配置（如密码）可在不同环境使用不同值

**使用示例**:
```java
// 加载开发环境配置: application-dev.properties
RpcConfig devConfig = ConfigUtils.loadConfig(RpcConfig.class, "rpc", "dev");

// 加载生产环境配置: application-prod.properties
RpcConfig prodConfig = ConfigUtils.loadConfig(RpcConfig.class, "rpc", "prod");
```

**配置文件组织**:
```
resources/
├── application.properties          # 默认配置
├── application-dev.properties      # 开发环境
├── application-test.properties     # 测试环境
└── application-prod.properties     # 生产环境
```

### 6.6 生命周期管理

**优势**:
- **自动初始化**: 配置加载时自动初始化注册中心
- **优雅关闭**: JVM 退出时自动释放资源
- **一体化管理**: 配置和资源管理统一在 `RpcApplication` 中

**生命周期流程**:
```
应用启动
    ↓
RpcApplication.init()
    ↓
加载配置 → 初始化注册中心 → 注册 ShutdownHook
    ↓
应用运行
    ↓
JVM 退出
    ↓
ShutdownHook 触发 → registry.destroy() → 关闭连接
```

## 7. 配置流转路径

```
┌─────────────────────────────────────────────────────────────┐
│                     配置加载与使用流程                        │
└─────────────────────────────────────────────────────────────┘

application.properties
    ↓
    ├─ rpc.name=yurpc
    ├─ rpc.serverPort=8080
    └─ rpc.registryConfig.address=http://localhost:2380

    ↓ (ConfigUtils.loadConfig)

RpcConfig 对象
    ↓
    ├─ name = "yurpc"
    ├─ serverPort = 8080
    └─ registryConfig
           └─ address = "http://localhost:2380"

    ↓ (RpcApplication.init)

全局单例存储
    ↓
    └─ static volatile RpcConfig rpcConfig

    ↓ (RpcApplication.getRpcConfig)

各组件使用配置
    ↓
    ├─ ProviderBootstrap → 获取 serverPort
    ├─ ServiceProxy → 获取 serializer
    ├─ RegistryFactory → 获取 registryConfig
    └─ LoadBalancerFactory → 获取 loadBalancer
```

## 8. 最佳实践

### 8.1 配置文件管理

**推荐做法**:
```properties
# 1. 基础配置（必填）
rpc.name=my-rpc-service
rpc.version=1.0
rpc.serverHost=0.0.0.0
rpc.serverPort=8080

# 2. 注册中心配置（必填）
rpc.registryConfig.registry=etcd
rpc.registryConfig.address=http://etcd-server:2380

# 3. 可选配置（有默认值）
rpc.serializer=kryo
rpc.loadBalancer=consistentHash
rpc.retryStrategy=fixedInterval
rpc.tolerantStrategy=failOver

# 4. 开发调试配置
rpc.mock=false
```

### 8.2 编程式配置

**适用场景**: 需要动态配置或配置来源不是文件

```java
public class CustomRpcInitializer {
    public static void init() {
        // 从数据库或配置中心加载配置
        RpcConfig config = loadConfigFromDatabase();

        // 初始化框架
        RpcApplication.init(config);
    }

    private static RpcConfig loadConfigFromDatabase() {
        RpcConfig config = new RpcConfig();
        // 从数据库查询配置
        config.setServerPort(queryPortFromDB());
        config.setSerializer(querySerializerFromDB());

        RegistryConfig registryConfig = new RegistryConfig();
        registryConfig.setAddress(queryRegistryAddressFromDB());
        config.setRegistryConfig(registryConfig);

        return config;
    }
}
```

### 8.3 配置验证

**建议**: 在初始化时验证关键配置

```java
public static void init(RpcConfig newRpcConfig) {
    // 验证配置
    validateConfig(newRpcConfig);

    rpcConfig = newRpcConfig;
    // ... 其他初始化逻辑
}

private static void validateConfig(RpcConfig config) {
    if (config.getServerPort() < 1024 || config.getServerPort() > 65535) {
        throw new IllegalArgumentException("Invalid server port: " + config.getServerPort());
    }

    if (config.getRegistryConfig() == null) {
        throw new IllegalArgumentException("Registry config is required");
    }

    // ... 其他验证
}
```

## 9. 总结

Yu-RPC-Core 的全局配置机制通过以下设计实现了高效、安全、易用的配置管理:

1. **分层配置类**: 职责清晰，易于扩展
2. **统一加载工具**: 基于 Hutool，支持多环境
3. **双检锁单例**: 线程安全的懒加载，高性能访问
4. **默认值机制**: 降低使用门槛，提高容错性
5. **生命周期管理**: 自动初始化和优雅关闭
6. **灵活配置方式**: 支持文件配置和编程式配置

这套配置机制是一个典型的配置中心实现方案，值得在其他项目中借鉴和应用。
