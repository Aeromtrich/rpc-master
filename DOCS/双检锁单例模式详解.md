# 双检锁单例模式详解

## 1. 什么是单例模式？

单例模式（Singleton Pattern）是一种设计模式，确保一个类只有一个实例，并提供一个全局访问点。

**为什么需要单例？**
- 全局配置对象：整个应用只需要一份配置
- 数据库连接池：避免创建多个连接池浪费资源
- 日志对象：统一管理日志输出
- 线程池：避免重复创建线程池

## 2. 单例模式的演进过程

### 2.1 最简单的单例（饿汉式）

```java
public class Singleton {
    // 类加载时就创建实例
    private static final Singleton instance = new Singleton();

    // 私有构造函数，防止外部创建实例
    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
```

**优点**：
- 简单，线程安全（类加载机制保证）
- 没有性能问题

**缺点**：
- 类加载时就创建实例，即使不使用也占用内存
- 无法延迟初始化（懒加载）

### 2.2 懒汉式（线程不安全）

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {  // 只有需要时才创建
            instance = new Singleton();
        }
        return instance;
    }
}
```

**优点**：
- 懒加载，节省内存

**缺点**：
- **线程不安全！** 多线程环境下可能创建多个实例

**多线程问题示例**：
```
时间线：
T1: 线程A 执行 if (instance == null)  → true
T2: 线程B 执行 if (instance == null)  → true (线程A还没创建完)
T3: 线程A 执行 instance = new Singleton()  → 创建实例1
T4: 线程B 执行 instance = new Singleton()  → 创建实例2

结果：创建了两个实例，违反单例原则！
```

### 2.3 懒汉式（加锁，线程安全但性能差）

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    // 整个方法加锁
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

**优点**：
- 线程安全
- 懒加载

**缺点**：
- **性能差！** 每次调用 `getInstance()` 都要加锁
- 实际上只有第一次创建实例时需要同步，后续调用不需要

**性能问题分析**：
```java
// 假设有 1000 次调用
for (int i = 0; i < 1000; i++) {
    Singleton.getInstance();  // 每次都要获取锁、释放锁
}

// 实际上只有第一次需要同步：
// 第1次：需要同步（创建实例）
// 第2-1000次：不需要同步（实例已存在），但还是要加锁！
```

### 2.4 双检锁（Double-Checked Locking）

```java
public class Singleton {
    // volatile 关键字很重要！
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        // 第一次检查：不加锁，快速判断
        if (instance == null) {
            // 加锁
            synchronized (Singleton.class) {
                // 第二次检查：防止重复创建
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**优点**：
- 线程安全
- 懒加载
- 性能好（只有第一次创建时才加锁）

## 3. 双检锁详细解析

### 3.1 为什么需要两次检查？

让我们用多线程场景来理解：

**场景：线程A和线程B同时调用 `getInstance()`**

```
初始状态：instance = null

时间线：
T1: 线程A 执行第一次检查 if (instance == null)  → true
T2: 线程B 执行第一次检查 if (instance == null)  → true
T3: 线程A 获取锁 synchronized (Singleton.class)
T4: 线程B 等待锁...
T5: 线程A 执行第二次检查 if (instance == null)  → true
T6: 线程A 执行 instance = new Singleton()  → 创建实例
T7: 线程A 释放锁
T8: 线程B 获取锁
T9: 线程B 执行第二次检查 if (instance == null)  → false (线程A已创建)
T10: 线程B 跳过创建，释放锁
```

**如果没有第二次检查会怎样？**

```java
// 错误示例：只有一次检查
public static Singleton getInstance() {
    if (instance == null) {
        synchronized (Singleton.class) {
            // 没有第二次检查！
            instance = new Singleton();  // 线程B会再次创建实例！
        }
    }
    return instance;
}
```

**问题**：
- 线程A和线程B都通过了第一次检查
- 线程A创建实例后释放锁
- 线程B获取锁后，没有再次检查，直接创建实例
- 结果：创建了两个实例！

### 3.2 为什么需要第一次检查？

**如果没有第一次检查会怎样？**

```java
// 性能差的版本：没有第一次检查
public static Singleton getInstance() {
    synchronized (Singleton.class) {  // 每次都加锁
        if (instance == null) {
            instance = new Singleton();
        }
    }
    return instance;
}
```

**问题**：
- 每次调用都要加锁，性能差
- 实际上实例创建后，后续调用不需要同步

**有第一次检查的好处**：
```java
// 性能好的版本：有第一次检查
public static Singleton getInstance() {
    if (instance == null) {  // 快速检查，不加锁
        synchronized (Singleton.class) {
            if (instance == null) {
                instance = new Singleton();
            }
        }
    }
    return instance;  // 大部分情况直接返回，不加锁
}
```

**性能对比**：
```
假设调用 1000 次：

没有第一次检查：
- 1000 次都要加锁、释放锁
- 性能：慢

有第一次检查：
- 第1次：加锁（创建实例）
- 第2-1000次：直接返回（不加锁）
- 性能：快
```

### 3.3 volatile 关键字的作用

**为什么必须加 volatile？**

```java
private static volatile Singleton instance;
```

**volatile 的两个作用**：

#### 作用1：保证内存可见性

```
没有 volatile 的问题：

线程A（CPU1）：
1. 创建实例
2. 将 instance 写入 CPU1 缓存
3. 还没刷新到主内存

线程B（CPU2）：
1. 从 CPU2 缓存读取 instance
2. 读到的是 null（因为线程A还没刷新到主内存）
3. 又创建了一个实例！

有 volatile：
- 线程A 写入 instance 后，立即刷新到主内存
- 线程B 读取 instance 前，从主内存读取最新值
- 保证线程B能看到线程A的修改
```

#### 作用2：禁止指令重排序

**这是最关键的！** 理解这个需要知道对象创建的过程。

**对象创建的三个步骤**：

```java
instance = new Singleton();

// JVM 实际执行的步骤：
1. 分配内存空间
2. 初始化对象（调用构造函数）
3. 将 instance 指向内存地址
```

**没有 volatile 时，JVM 可能会重排序**：

```java
// 正常顺序：
1. 分配内存空间
2. 初始化对象
3. instance 指向内存

// 重排序后：
1. 分配内存空间
3. instance 指向内存（对象还没初始化！）
2. 初始化对象
```

**重排序导致的问题**：

```
时间线：

T1: 线程A 执行 instance = new Singleton()
T2: 线程A 分配内存空间
T3: 线程A 将 instance 指向内存（对象还没初始化！）
T4: 线程B 执行第一次检查 if (instance == null)  → false
T5: 线程B 直接返回 instance（对象还没初始化完成！）
T6: 线程B 使用 instance，访问字段  → 空指针异常或错误数据！
T7: 线程A 初始化对象（太晚了）

结果：线程B 拿到了一个未完全初始化的对象！
```

**有 volatile 后**：
- 禁止指令重排序
- 保证对象完全初始化后，才将引用赋值给 instance
- 其他线程看到 instance 不为 null 时，对象一定是完全初始化的

### 3.4 完整的执行流程图

```
线程调用 getInstance()
    ↓
第一次检查: instance == null?
    ↓ No (已创建)
    └─→ 直接返回 instance (快速路径，不加锁)
    ↓ Yes (未创建)
获取类锁: synchronized(Singleton.class)
    ↓
第二次检查: instance == null?
    ↓ No (其他线程已创建)
    └─→ 释放锁，返回 instance
    ↓ Yes (确实需要创建)
创建实例: instance = new Singleton()
    ├─ 1. 分配内存
    ├─ 2. 初始化对象 (volatile 保证不重排序)
    └─ 3. 赋值给 instance (volatile 保证立即可见)
    ↓
释放锁
    ↓
返回 instance
```

## 4. Yu-RPC 中的双检锁实现

让我们看看 `RpcApplication.java:60-69` 的实现：

```java
public class RpcApplication {
    // volatile 保证可见性和禁止重排序
    private static volatile RpcConfig rpcConfig;

    public static RpcConfig getRpcConfig() {
        // 第一次检查：快速判断，不加锁
        if (rpcConfig == null) {
            // 加锁：保证只有一个线程创建实例
            synchronized (RpcApplication.class) {
                // 第二次检查：防止重复创建
                if (rpcConfig == null) {
                    init();  // 初始化配置
                }
            }
        }
        return rpcConfig;
    }
}
```

### 4.1 多线程场景模拟

**场景1：首次调用（多线程竞争）**

```
初始状态：rpcConfig = null

线程A、B、C 同时调用 getRpcConfig()

T1: 线程A 第一次检查 → null，准备加锁
T2: 线程B 第一次检查 → null，准备加锁
T3: 线程C 第一次检查 → null，准备加锁
T4: 线程A 获取锁
T5: 线程B、C 等待锁...
T6: 线程A 第二次检查 → null，执行 init()
T7: 线程A 创建配置对象，rpcConfig = newConfig
T8: 线程A 释放锁
T9: 线程B 获取锁
T10: 线程B 第二次检查 → 不为null（线程A已创建）
T11: 线程B 跳过 init()，释放锁
T12: 线程C 获取锁
T13: 线程C 第二次检查 → 不为null
T14: 线程C 跳过 init()，释放锁

结果：只创建了一个配置对象
```

**场景2：后续调用（高性能）**

```
状态：rpcConfig 已创建

线程D、E、F 调用 getRpcConfig()

T1: 线程D 第一次检查 → 不为null
T2: 线程D 直接返回 rpcConfig（不加锁！）
T3: 线程E 第一次检查 → 不为null
T4: 线程E 直接返回 rpcConfig（不加锁！）
T5: 线程F 第一次检查 → 不为null
T6: 线程F 直接返回 rpcConfig（不加锁！）

结果：快速返回，没有锁竞争
```

## 5. 常见问题解答

### Q1: 为什么不直接用 synchronized 修饰整个方法？

**答**：性能问题。

```java
// 方案1：整个方法加锁（性能差）
public static synchronized RpcConfig getRpcConfig() {
    if (rpcConfig == null) {
        init();
    }
    return rpcConfig;
}
// 每次调用都要加锁，即使对象已创建

// 方案2：双检锁（性能好）
public static RpcConfig getRpcConfig() {
    if (rpcConfig == null) {  // 大部分情况直接返回
        synchronized (RpcApplication.class) {
            if (rpcConfig == null) {
                init();
            }
        }
    }
    return rpcConfig;
}
// 只有第一次创建时加锁，后续调用不加锁
```

### Q2: 可以不用 volatile 吗？

**答**：不可以！会导致两个问题：

1. **可见性问题**：线程A创建的对象，线程B可能看不到
2. **重排序问题**：线程B可能拿到未完全初始化的对象

### Q3: 第二次检查可以去掉吗？

**答**：不可以！会导致重复创建实例。

```java
// 错误示例：没有第二次检查
if (rpcConfig == null) {
    synchronized (RpcApplication.class) {
        // 没有第二次检查
        init();  // 多个线程都会执行！
    }
}
```

### Q4: 第一次检查可以去掉吗？

**答**：可以，但性能会变差。

```java
// 可以工作，但性能差
synchronized (RpcApplication.class) {
    if (rpcConfig == null) {
        init();
    }
}
return rpcConfig;
// 每次调用都要加锁
```

### Q5: 为什么用 synchronized (RpcApplication.class) 而不是 synchronized (this)？

**答**：因为 `getRpcConfig()` 是静态方法，没有 `this`。

- 静态方法：锁类对象 `synchronized (ClassName.class)`
- 实例方法：锁实例对象 `synchronized (this)`

## 6. 其他单例实现方式

### 6.1 静态内部类（推荐）

```java
public class Singleton {
    private Singleton() {}

    // 静态内部类
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

**优点**：
- 懒加载（只有调用 `getInstance()` 时才加载内部类）
- 线程安全（类加载机制保证）
- 代码简洁，没有 volatile 和 synchronized

**原理**：
- JVM 保证类加载过程是线程安全的
- 只有访问 `Holder.INSTANCE` 时才加载 `Holder` 类
- `Holder` 类只会被加载一次

### 6.2 枚举（最安全）

```java
public enum Singleton {
    INSTANCE;

    public void doSomething() {
        // 业务方法
    }
}

// 使用
Singleton.INSTANCE.doSomething();
```

**优点**：
- 线程安全
- 防止反射攻击
- 防止序列化破坏单例
- 代码最简洁

**缺点**：
- 不能懒加载
- 不够灵活（枚举不能继承）

## 7. 总结

### 双检锁的三个关键点

1. **第一次检查**：提高性能，避免不必要的加锁
2. **synchronized**：保证线程安全，防止并发创建
3. **第二次检查**：防止重复创建实例
4. **volatile**：保证可见性和禁止重排序

### 适用场景

- 需要懒加载
- 对性能有要求
- 多线程环境
- 对象创建成本高（如 RpcConfig 需要加载配置文件、初始化注册中心）

### 记忆口诀

```
双检锁，三要素：
1. volatile 修饰变量（可见性 + 禁重排）
2. 两次 null 检查（性能 + 安全）
3. synchronized 加锁（防并发）

第一检查快速返回，
第二检查防止重复，
volatile 保证可见，
synchronized 保证安全。
```

### 代码模板

```java
public class Singleton {
    // 1. volatile 修饰
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        // 2. 第一次检查（不加锁）
        if (instance == null) {
            // 3. 加锁
            synchronized (Singleton.class) {
                // 4. 第二次检查
                if (instance == null) {
                    // 5. 创建实例
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

记住这个模板，理解每一行的作用，就能完全掌握双检锁单例模式了！
