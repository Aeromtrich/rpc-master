# Yu-RPC 容错机制详解

## 一、概述

容错机制是 RPC 框架中保障系统高可用性的最后一道防线。在分布式环境中，即使经过重试机制的处理，仍可能遇到持久性故障（如服务宕机、网络中断、超时等）。容错机制通过不同的策略来处理这些不可恢复的异常，避免单点故障导致整个系统崩溃。

Yu-RPC 框架实现了**四种经典的容错策略**，采用**策略模式 + SPI 机制**，支持灵活配置和自定义扩展。容错机制与重试机制协同工作，形成完整的故障处理体系。

## 二、整体架构

### 2.1 核心组件

容错机制由以下核心组件构成：

```
fault.tolerant/
├── TolerantStrategy.java              # 容错策略接口
├── TolerantStrategyKeys.java          # 容错策略键名常量
├── TolerantStrategyFactory.java       # 容错策略工厂
├── FailFastTolerantStrategy.java      # 快速失败策略
├── FailSafeTolerantStrategy.java      # 静默处理策略
├── FailOverTolerantStrategy.java      # 故障转移策略
└── FailBackTolerantStrategy.java      # 故障恢复策略
```

### 2.2 设计模式

1. **策略模式（Strategy Pattern）**：定义统一的容错策略接口，不同的容错算法实现该接口
2. **工厂模式（Factory Pattern）**：通过工厂类统一管理和创建容错策略实例
3. **SPI 机制（Service Provider Interface）**：实现容错策略的可插拔，支持自定义扩展

### 2.3 容错机制在 RPC 调用链中的位置

```
客户端调用
    ↓
动态代理拦截 (ServiceProxy)
    ↓
服务发现 + 负载均衡
    ↓
重试机制 (RetryStrategy)
    ↓ 成功
返回结果
    ↓ 失败（所有重试都失败）
容错机制 (TolerantStrategy) ← 最后一道防线
    ↓
返回降级结果 / 抛出异常
```

## 三、核心接口设计

### 3.1 TolerantStrategy 接口

```java
public interface TolerantStrategy {
    /**
     * 容错
     *
     * @param context 上下文，用于传递数据（如服务列表、请求信息等）
     * @param e       异常对象
     * @return RPC 响应结果
     */
    RpcResponse doTolerant(Map<String, Object> context, Exception e);
}
```

**设计要点**：
- `context` 参数：用于传递上下文信息，如服务节点列表、请求参数等，为高级容错策略（如故障转移）提供必要数据
- `e` 参数：捕获的异常对象，用于日志记录和异常分析
- 返回 `RpcResponse`：统一的响应类型，可以返回降级数据或空响应

### 3.2 TolerantStrategyKeys 常量类

```java
public interface TolerantStrategyKeys {
    String FAIL_BACK = "failBack";    // 故障恢复
    String FAIL_FAST = "failFast";    // 快速失败
    String FAIL_OVER = "failOver";    // 故障转移
    String FAIL_SAFE = "failSafe";    // 静默处理
}
```

**设计要点**：
- 定义四种经典的容错策略键名
- 用于配置文件和 SPI 加载
- 便于统一管理和避免硬编码

## 四、容错策略实现

### 4.1 FailFast - 快速失败策略

**实现代码**：
```java
public class FailFastTolerantStrategy implements TolerantStrategy {
    @Override
    public RpcResponse doTolerant(Map<String, Object> context, Exception e) {
        throw new RuntimeException("服务报错", e);
    }
}
```

**策略特点**：
- 立即将异常抛给外层调用方，不做任何处理
- 让调用方感知到服务失败，由调用方决定如何处理
- 适合对数据一致性要求高的场景

**适用场景**：
- 写操作（如订单创建、支付）：必须确保操作成功，失败需要立即通知用户
- 关键业务流程：不允许静默失败，需要明确的错误反馈
- 调试阶段：快速暴露问题，便于排查

**优点**：
- 简单直接，问题暴露及时
- 不会隐藏错误，便于监控和告警

**缺点**：
- 用户体验较差，直接看到错误信息
- 无降级能力，系统可用性较低

### 4.2 FailSafe - 静默处理策略

**实现代码**：
```java
@Slf4j
public class FailSafeTolerantStrategy implements TolerantStrategy {
    @Override
    public RpcResponse doTolerant(Map<String, Object> context, Exception e) {
        log.info("静默处理异常", e);
        return new RpcResponse();
    }
}
```

**策略特点**：
- 捕获异常并记录日志，但不抛出异常
- 返回一个空的 `RpcResponse` 对象
- 调用方感知不到服务失败，继续执行后续逻辑

**适用场景**：
- 非关键业务：如日志上报、埋点统计、推荐系统
- 读操作降级：查询失败时返回空结果，不影响主流程
- 可选功能：如用户头像加载失败，显示默认头像

**优点**：
- 提升系统可用性，不因局部故障影响整体
- 用户体验较好，感知不到错误

**缺点**：
- 可能隐藏问题，导致故障难以发现
- 需要依赖日志监控来发现异常

**注意事项**：
- 必须配合完善的日志监控和告警机制
- 不适用于对数据准确性要求高的场景

### 4.3 FailOver - 故障转移策略

**实现代码**：
```java
@Slf4j
public class FailOverTolerantStrategy implements TolerantStrategy {
    @Override
    public RpcResponse doTolerant(Map<String, Object> context, Exception e) {
        // todo 可自行扩展，获取其他服务节点并调用
        return null;
    }
}
```

**策略特点**：
- 当前服务节点失败后，自动切换到其他可用节点重试
- 需要从 `context` 中获取服务节点列表
- 当前实现为扩展点，需要用户自行实现

**设计思路**（扩展实现）：
```java
@Override
public RpcResponse doTolerant(Map<String, Object> context, Exception e) {
    // 1. 从 context 获取服务节点列表
    List<ServiceMetaInfo> serviceList = (List<ServiceMetaInfo>) context.get("serviceList");
    ServiceMetaInfo failedService = (ServiceMetaInfo) context.get("currentService");

    // 2. 过滤掉失败的节点
    List<ServiceMetaInfo> availableServices = serviceList.stream()
        .filter(service -> !service.equals(failedService))
        .collect(Collectors.toList());

    // 3. 选择新节点并重试
    if (!availableServices.isEmpty()) {
        ServiceMetaInfo newService = availableServices.get(0);
        RpcRequest request = (RpcRequest) context.get("request");
        return VertxTcpClient.doRequest(request, newService);
    }

    // 4. 无可用节点，抛出异常
    throw new RuntimeException("所有服务节点均不可用", e);
}
```

**适用场景**：
- 多节点部署的服务：有多个服务提供者可供选择
- 读操作：可以安全地切换到其他节点
- 对可用性要求极高的场景

**优点**：
- 最大化系统可用性，充分利用冗余节点
- 对用户透明，自动完成故障恢复

**缺点**：
- 增加响应时间（需要额外的重试）
- 可能导致请求重复（如果是写操作需要保证幂等性）
- 实现复杂度较高

**注意事项**：
- 需要与负载均衡器配合，避免重复选择失败节点
- 写操作需要保证幂等性，避免重复执行
- 需要设置最大转移次数，避免无限循环

### 4.4 FailBack - 故障恢复策略

**实现代码**：
```java
@Slf4j
public class FailBackTolerantStrategy implements TolerantStrategy {
    @Override
    public RpcResponse doTolerant(Map<String, Object> context, Exception e) {
        // todo 可自行扩展，获取降级的服务并调用
        return null;
    }
}
```

**策略特点**：
- 调用失败后，降级到备用服务或本地缓存
- 与 FailOver 的区别：FailOver 是切换到同类服务的其他节点，FailBack 是降级到不同的服务
- 当前实现为扩展点，需要用户自行实现

**设计思路**（扩展实现）：
```java
@Override
public RpcResponse doTolerant(Map<String, Object> context, Exception e) {
    // 1. 尝试从本地缓存获取
    String cacheKey = (String) context.get("cacheKey");
    Object cachedData = localCache.get(cacheKey);
    if (cachedData != null) {
        log.info("使用缓存数据降级");
        RpcResponse response = new RpcResponse();
        response.setData(cachedData);
        return response;
    }

    // 2. 调用降级服务（如返回默认值）
    Object defaultValue = getDefaultValue(context);
    RpcResponse response = new RpcResponse();
    response.setData(defaultValue);

    // 3. 异步记录失败请求，后续重试
    asyncRetryQueue.add(context);

    return response;
}
```

**适用场景**：
- 有缓存机制的查询服务：优先返回缓存数据
- 有默认值的场景：如推荐系统返回热门商品
- 需要异步补偿的场景：先返回默认值，后台异步重试

**优点**：
- 提供降级能力，保证基本可用
- 可以结合缓存、默认值等多种降级手段
- 支持异步补偿机制

**缺点**：
- 返回的数据可能不是最新的
- 实现复杂度高，需要维护缓存和降级逻辑

**注意事项**：
- 缓存数据需要设置合理的过期时间
- 降级数据需要明确标识，避免误导用户
- 异步补偿需要保证最终一致性

## 五、工厂类与 SPI 加载

### 5.1 TolerantStrategyFactory 工厂类

```java
public class TolerantStrategyFactory {
    static {
        SpiLoader.load(TolerantStrategy.class);  // 静态代码块加载 SPI
    }

    /**
     * 默认容错策略
     */
    private static final TolerantStrategy DEFAULT_RETRY_STRATEGY = new FailFastTolerantStrategy();

    public static TolerantStrategy getInstance(String key) {
        return SpiLoader.getInstance(TolerantStrategy.class, key);
    }
}
```

**设计要点**：
- 静态代码块在类加载时自动加载所有 `TolerantStrategy` 的 SPI 实现
- 默认容错策略为 `FailFast`（快速失败），符合"尽早暴露问题"的原则
- 通过 `key` 获取对应的容错策略实例

### 5.2 SPI 配置文件

**文件路径**：`yu-rpc-core/src/main/resources/META-INF/rpc/system/com.yupi.yurpc.fault.tolerant.TolerantStrategy`

**文件内容**：
```properties
failBack=com.yupi.yurpc.fault.tolerant.FailBackTolerantStrategy
failFast=com.yupi.yurpc.fault.tolerant.FailFastTolerantStrategy
failOver=com.yupi.yurpc.fault.tolerant.FailOverTolerantStrategy
failSafe=com.yupi.yurpc.fault.tolerant.FailSafeTolerantStrategy
```

**SPI 机制优势**：
- 实现容错策略的可插拔，无需修改核心代码
- 支持用户自定义容错策略（在 `META-INF/rpc/custom/` 目录下配置）
- 延迟加载，按需创建实例

## 六、配置与使用

### 6.1 全局配置

在 `RpcConfig` 中定义容错策略配置项：

```java
@Data
public class RpcConfig {
    /**
     * 容错策略
     */
    private String tolerantStrategy = TolerantStrategyKeys.FAIL_FAST;  // 默认快速失败

    // ... 其他配置
}
```

### 6.2 配置文件

在 `application.properties` 或 `application.yml` 中配置：

```properties
# 快速失败（默认）
rpc.tolerantStrategy=failFast

# 静默处理
rpc.tolerantStrategy=failSafe

# 故障转移
rpc.tolerantStrategy=failOver

# 故障恢复
rpc.tolerantStrategy=failBack
```

### 6.3 在代理层使用

容错机制在 `ServiceProxy` 的 `invoke` 方法中被调用（`ServiceProxy.java:88-92`）：

```java
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    // ... 构造请求、服务发现、负载均衡 ...

    RpcResponse rpcResponse;
    try {
        // 先使用重试机制
        RetryStrategy retryStrategy = RetryStrategyFactory.getInstance(rpcConfig.getRetryStrategy());
        rpcResponse = retryStrategy.doRetry(() ->
                VertxTcpClient.doRequest(rpcRequest, selectedServiceMetaInfo)
        );
    } catch (Exception e) {
        // 重试失败后触发容错机制
        TolerantStrategy tolerantStrategy = TolerantStrategyFactory.getInstance(rpcConfig.getTolerantStrategy());
        rpcResponse = tolerantStrategy.doTolerant(null, e);
    }

    return rpcResponse.getData();
}
```

**执行流程**：
1. 先执行重试机制，尝试多次调用
2. 如果重试全部失败，捕获异常
3. 根据配置获取容错策略实例
4. 执行容错策略，返回降级结果或抛出异常

## 七、容错机制与重试机制的协作

### 7.1 两层防护体系

```
┌─────────────────────────────────────────┐
│          RPC 调用请求                    │
└─────────────────┬───────────────────────┘
                  ↓
         ┌────────────────┐
         │  第一层：重试机制  │  处理临时性故障
         │  - 网络抖动      │  (可恢复的异常)
         │  - 服务暂时不可用 │
         └────────┬───────┘
                  ↓ 成功
            返回正常结果
                  ↓ 失败（所有重试都失败）
         ┌────────────────┐
         │  第二层：容错机制  │  处理持久性故障
         │  - 服务宕机      │  (不可恢复的异常)
         │  - 网络中断      │
         │  - 超时         │
         └────────┬───────┘
                  ↓
    ┌─────────────┴─────────────┐
    ↓                           ↓
快速失败/静默处理          故障转移/故障恢复
(返回异常/空结果)          (切换节点/降级服务)
```

### 7.2 协作原则

1. **职责分离**：
   - 重试机制：处理临时性、可恢复的故障
   - 容错机制：处理持久性、不可恢复的故障

2. **顺序执行**：
   - 先重试，后容错
   - 重试失败后才触发容错

3. **策略组合**：
   - 重试策略 + 容错策略可以自由组合
   - 例如：`fixedInterval` 重试 + `failSafe` 容错

### 7.3 典型组合场景

| 业务场景 | 重试策略 | 容错策略 | 说明 |
|---------|---------|---------|------|
| 订单创建 | `fixedInterval` | `failFast` | 重试 3 次，失败立即通知用户 |
| 用户查询 | `fixedInterval` | `failSafe` | 重试 3 次，失败返回空结果 |
| 推荐服务 | `no` | `failBack` | 不重试，直接降级到默认推荐 |
| 日志上报 | `no` | `failSafe` | 不重试，静默处理，不影响主流程 |
| 支付回调 | `fixedInterval` | `failOver` | 重试 3 次，失败切换到备用节点 |

## 八、容错策略选择指南

### 8.1 决策树

```
是否允许失败？
├─ 否（关键业务）→ FailFast（快速失败）
│   例如：订单创建、支付、转账
│
└─ 是（非关键业务）
    ├─ 有备用节点？
    │   ├─ 是（同类服务）→ FailOver（故障转移）
    │   │   例如：多节点部署的查询服务
    │   │
    │   └─ 是（降级服务）→ FailBack（故障恢复）
    │       例如：推荐系统、缓存服务
    │
    └─ 无备用节点 → FailSafe（静默处理）
        例如：日志上报、埋点统计
```

### 8.2 策略对比

| 策略 | 可用性 | 数据准确性 | 响应时间 | 实现复杂度 | 适用场景 |
|-----|-------|----------|---------|----------|---------|
| FailFast | ★☆☆☆☆ | ★★★★★ | ★★★★★ | ★☆☆☆☆ | 关键业务、写操作 |
| FailSafe | ★★★★★ | ★☆☆☆☆ | ★★★★★ | ★☆☆☆☆ | 非关键业务、日志上报 |
| FailOver | ★★★★☆ | ★★★★☆ | ★★☆☆☆ | ★★★☆☆ | 多节点部署、读操作 |
| FailBack | ★★★★☆ | ★★☆☆☆ | ★★★★☆ | ★★★★☆ | 有缓存、有默认值 |

## 九、扩展指南

### 9.1 自定义容错策略

**步骤 1**：实现 `TolerantStrategy` 接口

```java
@Slf4j
public class CircuitBreakerTolerantStrategy implements TolerantStrategy {
    private final CircuitBreaker circuitBreaker = new CircuitBreaker();

    @Override
    public RpcResponse doTolerant(Map<String, Object> context, Exception e) {
        // 记录失败
        circuitBreaker.recordFailure();

        // 检查熔断器状态
        if (circuitBreaker.isOpen()) {
            log.warn("熔断器已打开，直接返回降级结果");
            return getFallbackResponse(context);
        }

        // 熔断器关闭，抛出异常
        throw new RuntimeException("服务调用失败", e);
    }

    private RpcResponse getFallbackResponse(Map<String, Object> context) {
        // 返回降级数据
        RpcResponse response = new RpcResponse();
        response.setData(getDefaultValue(context));
        return response;
    }
}
```

**步骤 2**：注册到 SPI 配置文件

在 `META-INF/rpc/custom/com.yupi.yurpc.fault.tolerant.TolerantStrategy` 中添加：

```properties
circuitBreaker=com.example.CircuitBreakerTolerantStrategy
```

**步骤 3**：配置使用

```properties
rpc.tolerantStrategy=circuitBreaker
```

### 9.2 完善 FailOver 策略

```java
@Slf4j
public class FailOverTolerantStrategy implements TolerantStrategy {
    private static final int MAX_RETRY_TIMES = 3;

    @Override
    public RpcResponse doTolerant(Map<String, Object> context, Exception e) {
        // 获取上下文信息
        List<ServiceMetaInfo> serviceList = (List<ServiceMetaInfo>) context.get("serviceList");
        ServiceMetaInfo failedService = (ServiceMetaInfo) context.get("currentService");
        RpcRequest request = (RpcRequest) context.get("request");

        // 过滤失败节点
        List<ServiceMetaInfo> availableServices = serviceList.stream()
            .filter(service -> !service.equals(failedService))
            .collect(Collectors.toList());

        // 尝试其他节点
        for (int i = 0; i < Math.min(MAX_RETRY_TIMES, availableServices.size()); i++) {
            try {
                ServiceMetaInfo newService = availableServices.get(i);
                log.info("故障转移到节点: {}", newService.getServiceAddress());
                return VertxTcpClient.doRequest(request, newService);
            } catch (Exception ex) {
                log.warn("节点 {} 调用失败，尝试下一个节点", availableServices.get(i).getServiceAddress());
            }
        }

        // 所有节点都失败
        throw new RuntimeException("所有服务节点均不可用", e);
    }
}
```

### 9.3 完善 FailBack 策略

```java
@Slf4j
public class FailBackTolerantStrategy implements TolerantStrategy {
    private final LoadingCache<String, Object> cache = CacheBuilder.newBuilder()
        .expireAfterWrite(10, TimeUnit.MINUTES)
        .build();

    private final ExecutorService asyncExecutor = Executors.newFixedThreadPool(5);

    @Override
    public RpcResponse doTolerant(Map<String, Object> context, Exception e) {
        String cacheKey = buildCacheKey(context);

        // 1. 尝试从缓存获取
        Object cachedData = cache.getIfPresent(cacheKey);
        if (cachedData != null) {
            log.info("使用缓存数据降级");
            RpcResponse response = new RpcResponse();
            response.setData(cachedData);
            return response;
        }

        // 2. 返回默认值
        Object defaultValue = getDefaultValue(context);
        RpcResponse response = new RpcResponse();
        response.setData(defaultValue);

        // 3. 异步重试并更新缓存
        asyncExecutor.submit(() -> {
            try {
                RpcRequest request = (RpcRequest) context.get("request");
                ServiceMetaInfo service = (ServiceMetaInfo) context.get("currentService");
                RpcResponse result = VertxTcpClient.doRequest(request, service);
                cache.put(cacheKey, result.getData());
                log.info("异步重试成功，已更新缓存");
            } catch (Exception ex) {
                log.error("异步重试失败", ex);
            }
        });

        return response;
    }

    private String buildCacheKey(Map<String, Object> context) {
        RpcRequest request = (RpcRequest) context.get("request");
        return request.getServiceName() + ":" + request.getMethodName();
    }

    private Object getDefaultValue(Map<String, Object> context) {
        // 根据业务返回默认值
        return null;
    }
}
```

## 十、最佳实践

### 10.1 容错策略选择原则

1. **关键业务优先保证数据准确性**：使用 `FailFast`，让问题尽早暴露
2. **非关键业务优先保证可用性**：使用 `FailSafe` 或 `FailBack`
3. **多节点部署充分利用冗余**：使用 `FailOver`
4. **有缓存或默认值的场景**：使用 `FailBack`

### 10.2 监控与告警

1. **记录容错触发次数**：监控各容错策略的调用频率
2. **设置告警阈值**：容错触发次数过高时及时告警
3. **日志完整性**：记录异常堆栈、请求参数、服务节点信息

### 10.3 注意事项

1. **FailSafe 不能滥用**：必须配合监控，避免隐藏问题
2. **FailOver 需要保证幂等性**：避免重复执行写操作
3. **FailBack 需要明确标识降级数据**：避免误导用户
4. **容错策略要与业务特性匹配**：不能一刀切

## 十一、总结

Yu-RPC 的容错机制通过四种经典策略，为不同业务场景提供了灵活的故障处理方案：

1. **FailFast**：快速失败，适合关键业务
2. **FailSafe**：静默处理，适合非关键业务
3. **FailOver**：故障转移，适合多节点部署
4. **FailBack**：故障恢复，适合有降级方案的场景

容错机制与重试机制协同工作，形成两层防护体系，有效提升了系统的高可用性和容错能力。通过 SPI 机制，用户可以轻松扩展自定义容错策略，满足特定业务需求。
