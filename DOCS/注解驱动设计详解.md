# Yu-RPC Spring Boot Starter 注解驱动设计详解

## 一、概述

Yu-RPC Spring Boot Starter 通过注解驱动的方式，将 RPC 框架无缝集成到 Spring Boot 应用中。开发者只需添加几个注解，即可实现服务的发布和消费，无需编写繁琐的配置代码。

### 1.1 核心注解

- `@EnableRpc`：启用 RPC 框架，标注在 Spring Boot 启动类上
- `@RpcService`：标注服务提供者，自动注册服务
- `@RpcReference`：标注服务消费者，自动注入 RPC 代理对象

### 1.2 设计目标

1. **零配置**：通过注解自动完成服务注册和发现
2. **Spring 集成**：利用 Spring 的生命周期和依赖注入机制
3. **透明化**：对业务代码无侵入，使用方式与本地调用一致
4. **可配置**：支持通过注解参数自定义负载均衡、重试、容错等策略

## 二、核心注解设计

### 2.1 @EnableRpc - 启用 RPC 框架

**源码位置**：`com.yupi.yurpc.springboot.starter.annotation.EnableRpc`

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Import({RpcInitBootstrap.class, RpcProviderBootstrap.class, RpcConsumerBootstrap.class})
public @interface EnableRpc {
    /**
     * 需要启动 server
     */
    boolean needServer() default true;
}
```

**设计要点**：

1. **@Import 机制**：通过 Spring 的 `@Import` 注解导入三个核心 Bootstrap 类
   - `RpcInitBootstrap`：初始化 RPC 框架
   - `RpcProviderBootstrap`：处理服务提供者注册
   - `RpcConsumerBootstrap`：处理服务消费者注入

2. **needServer 参数**：
   - `true`（默认）：启动 TCP 服务器，适用于服务提供者
   - `false`：不启动服务器，适用于纯消费者应用

**使用示例**：

```java
// 服务提供者
@SpringBootApplication
@EnableRpc  // 默认启动服务器
public class ProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProviderApplication.class, args);
    }
}

// 服务消费者
@SpringBootApplication
@EnableRpc(needServer = false)  // 不启动服务器
public class ConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class, args);
    }
}
```

### 2.2 @RpcService - 服务提供者注解

**源码位置**：`com.yupi.yurpc.springboot.starter.annotation.RpcService`

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Component
public @interface RpcService {
    /**
     * 服务接口类
     */
    Class<?> interfaceClass() default void.class;

    /**
     * 版本
     */
    String serviceVersion() default RpcConstant.DEFAULT_SERVICE_VERSION;
}
```

**设计要点**：

1. **@Component 元注解**：使被标注的类自动成为 Spring Bean
2. **interfaceClass 参数**：
   - 指定服务接口类型
   - 默认 `void.class`，表示自动推断（使用实现类的第一个接口）
3. **serviceVersion 参数**：支持服务版本控制，实现灰度发布

**使用示例**：

```java
@Service
@RpcService  // 自动推断接口为 UserService
public class UserServiceImpl implements UserService {
    @Override
    public User getUser(User user) {
        System.out.println("用户名：" + user.getName());
        return user;
    }
}

// 显式指定接口和版本
@Service
@RpcService(interfaceClass = UserService.class, serviceVersion = "2.0")
public class UserServiceV2Impl implements UserService {
    // ...
}
```

### 2.3 @RpcReference - 服务消费者注解

**源码位置**：`com.yupi.yurpc.springboot.starter.annotation.RpcReference`

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface RpcReference {
    /**
     * 服务接口类
     */
    Class<?> interfaceClass() default void.class;

    /**
     * 版本
     */
    String serviceVersion() default RpcConstant.DEFAULT_SERVICE_VERSION;

    /**
     * 负载均衡器
     */
    String loadBalancer() default LoadBalancerKeys.ROUND_ROBIN;

    /**
     * 重试策略
     */
    String retryStrategy() default RetryStrategyKeys.NO;

    /**
     * 容错策略
     */
    String tolerantStrategy() default TolerantStrategyKeys.FAIL_FAST;

    /**
     * 模拟调用
     */
    boolean mock() default false;
}
```

**设计要点**：

1. **字段级注解**：`@Target(ElementType.FIELD)` 标注在字段上
2. **丰富的配置参数**：
   - `interfaceClass`：服务接口类型（默认使用字段类型）
   - `serviceVersion`：服务版本
   - `loadBalancer`：负载均衡策略（轮询、随机、一致性哈希）
   - `retryStrategy`：重试策略（无重试、固定间隔）
   - `tolerantStrategy`：容错策略（快速失败、静默失败、故障转移、故障恢复）
   - `mock`：是否启用 Mock 模式

**使用示例**：

```java
@Service
public class ExampleServiceImpl {
    // 基本使用
    @RpcReference
    private UserService userService;

    // 自定义配置
    @RpcReference(
        loadBalancer = LoadBalancerKeys.CONSISTENT_HASH,
        retryStrategy = RetryStrategyKeys.FIXED_INTERVAL,
        tolerantStrategy = TolerantStrategyKeys.FAIL_OVER
    )
    private OrderService orderService;

    public void test() {
        User user = new User();
        user.setName("yupi");
        User resultUser = userService.getUser(user);
        System.out.println(resultUser.getName());
    }
}
```


## 三、Bootstrap 启动流程

### 3.1 RpcInitBootstrap - 框架初始化

**源码位置**：`com.yupi.yurpc.springboot.starter.bootstrap.RpcInitBootstrap`

```java
@Slf4j
public class RpcInitBootstrap implements ImportBeanDefinitionRegistrar {

    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, 
                                       BeanDefinitionRegistry registry) {
        // 1. 获取 EnableRpc 注解的属性值
        boolean needServer = (boolean) importingClassMetadata
                .getAnnotationAttributes(EnableRpc.class.getName())
                .get("needServer");

        // 2. RPC 框架初始化（配置和注册中心）
        RpcApplication.init();

        // 3. 全局配置
        final RpcConfig rpcConfig = RpcApplication.getRpcConfig();

        // 4. 启动服务器
        if (needServer) {
            VertxTcpServer vertxTcpServer = new VertxTcpServer();
            vertxTcpServer.doStart(rpcConfig.getServerPort());
        } else {
            log.info("不启动 server");
        }
    }
}
```

**设计要点**：

1. **ImportBeanDefinitionRegistrar 接口**：
   - Spring 提供的扩展点，在 Bean 定义注册阶段执行
   - 比 `@Configuration` 更早执行，适合做框架初始化

2. **执行时机**：Spring 容器启动时，在 Bean 实例化之前执行

3. **初始化流程**：
   ```
   获取 @EnableRpc 注解参数
         ↓
   调用 RpcApplication.init()
   （加载配置文件、初始化注册中心）
         ↓
   根据 needServer 参数决定是否启动 TCP 服务器
   ```

4. **职责**：
   - 加载 `application.properties` 中的 RPC 配置
   - 初始化注册中心连接（Etcd/ZooKeeper）
   - 启动 Vert.x TCP 服务器（如果需要）

### 3.2 RpcProviderBootstrap - 服务提供者启动

**源码位置**：`com.yupi.yurpc.springboot.starter.bootstrap.RpcProviderBootstrap`

```java
@Slf4j
public class RpcProviderBootstrap implements BeanPostProcessor {

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) 
            throws BeansException {
        Class<?> beanClass = bean.getClass();
        RpcService rpcService = beanClass.getAnnotation(RpcService.class);
        
        if (rpcService != null) {
            // 1. 获取服务基本信息
            Class<?> interfaceClass = rpcService.interfaceClass();
            if (interfaceClass == void.class) {
                // 默认使用实现类的第一个接口
                interfaceClass = beanClass.getInterfaces()[0];
            }
            String serviceName = interfaceClass.getName();
            String serviceVersion = rpcService.serviceVersion();
            
            // 2. 本地注册
            LocalRegistry.register(serviceName, beanClass);

            // 3. 注册到注册中心
            final RpcConfig rpcConfig = RpcApplication.getRpcConfig();
            RegistryConfig registryConfig = rpcConfig.getRegistryConfig();
            Registry registry = RegistryFactory.getInstance(registryConfig.getRegistry());
            
            ServiceMetaInfo serviceMetaInfo = new ServiceMetaInfo();
            serviceMetaInfo.setServiceName(serviceName);
            serviceMetaInfo.setServiceVersion(serviceVersion);
            serviceMetaInfo.setServiceHost(rpcConfig.getServerHost());
            serviceMetaInfo.setServicePort(rpcConfig.getServerPort());
            
            try {
                registry.register(serviceMetaInfo);
            } catch (Exception e) {
                throw new RuntimeException(serviceName + " 服务注册失败", e);
            }
        }

        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);
    }
}
```

**设计要点**：

1. **BeanPostProcessor 接口**：
   - Spring Bean 后置处理器，在 Bean 初始化后执行
   - `postProcessAfterInitialization` 方法在每个 Bean 创建后都会被调用

2. **执行时机**：每个 Spring Bean 初始化完成后

3. **注册流程**：
   ```
   检查 Bean 是否有 @RpcService 注解
         ↓
   解析服务接口和版本信息
         ↓
   注册到本地注册表（LocalRegistry）
   （serviceName → 实现类 Class 映射）
         ↓
   构建服务元信息（ServiceMetaInfo）
   （包含服务名、版本、主机、端口）
         ↓
   注册到分布式注册中心（Etcd/ZooKeeper）
   ```

4. **双重注册机制**：
   - **本地注册**：`LocalRegistry` 存储服务名到实现类的映射，用于请求到达时通过反射调用
   - **远程注册**：注册中心存储服务元信息，用于服务发现

### 3.3 RpcConsumerBootstrap - 服务消费者启动

**源码位置**：`com.yupi.yurpc.springboot.starter.bootstrap.RpcConsumerBootstrap`

```java
@Slf4j
public class RpcConsumerBootstrap implements BeanPostProcessor {

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) 
            throws BeansException {
        Class<?> beanClass = bean.getClass();
        
        // 遍历对象的所有属性
        Field[] declaredFields = beanClass.getDeclaredFields();
        for (Field field : declaredFields) {
            // 检查字段是否有 @RpcReference 注解
            RpcReference rpcReference = field.getAnnotation(RpcReference.class);
            if (rpcReference != null) {
                // 1. 确定服务接口类型
                Class<?> interfaceClass = rpcReference.interfaceClass();
                if (interfaceClass == void.class) {
                    // 默认使用字段类型
                    interfaceClass = field.getType();
                }
                
                // 2. 生成代理对象
                field.setAccessible(true);
                Object proxyObject = ServiceProxyFactory.getProxy(interfaceClass);
                
                try {
                    // 3. 将代理对象注入到 Bean 字段中
                    field.set(bean, proxyObject);
                    field.setAccessible(false);
                } catch (IllegalAccessException e) {
                    throw new RuntimeException("为字段注入代理对象失败", e);
                }
            }
        }
        
        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);
    }
}
```

**设计要点**：

1. **字段注入机制**：
   - 遍历 Bean 的所有字段
   - 查找标注了 `@RpcReference` 的字段
   - 通过反射注入代理对象

2. **执行时机**：每个 Spring Bean 初始化完成后

3. **代理注入流程**：
   ```
   遍历 Bean 的所有字段
         ↓
   查找 @RpcReference 注解
         ↓
   解析服务接口类型
   （优先使用 interfaceClass，否则使用字段类型）
         ↓
   调用 ServiceProxyFactory.getProxy() 创建代理对象
   （JDK 动态代理）
         ↓
   通过反射将代理对象注入到字段
   （field.set(bean, proxyObject)）
   ```

4. **代理对象职责**：
   - 拦截方法调用
   - 执行服务发现、负载均衡、序列化、网络传输
   - 处理重试和容错逻辑


## 四、完整启动流程

### 4.1 服务提供者启动流程

```
Spring Boot 应用启动
         ↓
扫描到 @EnableRpc 注解
         ↓
通过 @Import 导入三个 Bootstrap 类
         ↓
【阶段1：框架初始化】RpcInitBootstrap.registerBeanDefinitions()
   - 加载 application.properties 配置
   - 初始化注册中心客户端
   - 启动 Vert.x TCP 服务器（监听 8080 端口）
         ↓
【阶段2：Bean 创建】Spring 创建所有 Bean
         ↓
【阶段3：服务注册】RpcProviderBootstrap.postProcessAfterInitialization()
   - 扫描 @RpcService 注解的 Bean
   - 注册到 LocalRegistry（本地映射表）
   - 注册到 Etcd/ZooKeeper（分布式注册中心）
         ↓
应用启动完成，等待 RPC 请求
```

**时序图**：

```
用户代码                Spring容器              RpcInitBootstrap        RpcProviderBootstrap
   |                       |                         |                         |
   |--@EnableRpc---------->|                         |                         |
   |                       |--registerBeanDefinitions-->|                      |
   |                       |                         |--RpcApplication.init()  |
   |                       |                         |--启动TCP服务器          |
   |                       |                         |                         |
   |                       |--创建Bean-------------->|                         |
   |                       |                         |                         |
   |                       |--postProcessAfterInit-->|                         |
   |                       |                         |--扫描@RpcService------->|
   |                       |                         |                         |--LocalRegistry.register()
   |                       |                         |                         |--Registry.register()
   |                       |<------------------------|                         |
   |<----------------------|                         |                         |
```

### 4.2 服务消费者启动流程

```
Spring Boot 应用启动
         ↓
扫描到 @EnableRpc(needServer = false) 注解
         ↓
通过 @Import 导入三个 Bootstrap 类
         ↓
【阶段1：框架初始化】RpcInitBootstrap.registerBeanDefinitions()
   - 加载 application.properties 配置
   - 初始化注册中心客户端
   - 不启动 TCP 服务器（needServer = false）
         ↓
【阶段2：Bean 创建】Spring 创建所有 Bean
         ↓
【阶段3：代理注入】RpcConsumerBootstrap.postProcessAfterInitialization()
   - 扫描 @RpcReference 注解的字段
   - 创建 JDK 动态代理对象
   - 通过反射注入到字段
         ↓
应用启动完成，可以调用远程服务
```

**时序图**：

```
用户代码                Spring容器              RpcInitBootstrap        RpcConsumerBootstrap
   |                       |                         |                         |
   |--@EnableRpc(false)--->|                         |                         |
   |                       |--registerBeanDefinitions-->|                      |
   |                       |                         |--RpcApplication.init()  |
   |                       |                         |--不启动服务器           |
   |                       |                         |                         |
   |                       |--创建Bean-------------->|                         |
   |                       |                         |                         |
   |                       |--postProcessAfterInit-->|                         |
   |                       |                         |--扫描@RpcReference----->|
   |                       |                         |                         |--ServiceProxyFactory.getProxy()
   |                       |                         |                         |--field.set(bean, proxy)
   |                       |<------------------------|                         |
   |<----------------------|                         |                         |
```

## 五、核心设计模式

### 5.1 注解驱动模式

**实现机制**：
- 使用 Java 注解作为元数据标记
- 通过 Spring 的扩展点（`ImportBeanDefinitionRegistrar`、`BeanPostProcessor`）扫描和处理注解
- 在 Spring 容器生命周期的特定阶段执行自定义逻辑

**优势**：
- 声明式编程，代码简洁
- 与 Spring 生态无缝集成
- 对业务代码无侵入

### 5.2 代理模式

**实现机制**：
- 使用 JDK 动态代理创建服务接口的代理对象
- 代理对象拦截方法调用，执行 RPC 调用逻辑
- 通过 `ServiceProxyFactory` 统一管理代理对象创建

**核心代码**（yu-rpc-core）：

```java
public class ServiceProxy implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        // 1. 构造 RPC 请求
        RpcRequest rpcRequest = RpcRequest.builder()
                .serviceName(method.getDeclaringClass().getName())
                .methodName(method.getName())
                .parameterTypes(method.getParameterTypes())
                .args(args)
                .build();

        // 2. 服务发现
        List<ServiceMetaInfo> serviceMetaInfoList = 
                registry.serviceDiscovery(rpcRequest.getServiceName());

        // 3. 负载均衡
        ServiceMetaInfo selectedService = 
                loadBalancer.select(requestParams, serviceMetaInfoList);

        // 4. 发送 RPC 请求
        RpcResponse rpcResponse = 
                VertxTcpClient.doRequest(rpcRequest, selectedService);

        return rpcResponse.getData();
    }
}
```

### 5.3 后置处理器模式

**BeanPostProcessor 接口**：
- Spring 提供的扩展点，在 Bean 生命周期中插入自定义逻辑
- `postProcessAfterInitialization` 在 Bean 初始化后执行

**应用场景**：
- `RpcProviderBootstrap`：扫描 `@RpcService` 注解，注册服务
- `RpcConsumerBootstrap`：扫描 `@RpcReference` 注解，注入代理对象

**执行顺序**：
```
Bean 实例化
    ↓
依赖注入
    ↓
BeanPostProcessor.postProcessBeforeInitialization()
    ↓
InitializingBean.afterPropertiesSet()
    ↓
BeanPostProcessor.postProcessAfterInitialization()  ← 我们的逻辑在这里
    ↓
Bean 可用
```

### 5.4 工厂模式

**ServiceProxyFactory**：
- 统一管理代理对象的创建
- 支持 Mock 模式切换
- 缓存代理对象，避免重复创建

```java
public class ServiceProxyFactory {
    public static <T> T getProxy(Class<T> serviceClass) {
        if (RpcApplication.getRpcConfig().isMock()) {
            return getMockProxy(serviceClass);
        }
        return (T) Proxy.newProxyInstance(
            serviceClass.getClassLoader(),
            new Class[]{serviceClass},
            new ServiceProxy()
        );
    }
}
```


## 六、完整使用示例

### 6.1 项目结构

```
my-rpc-project/
├── common/                          # 公共模块
│   └── src/main/java/
│       └── com/example/service/
│           └── UserService.java     # 服务接口
├── provider/                        # 服务提供者
│   └── src/main/java/
│       ├── com/example/
│       │   ├── ProviderApplication.java
│       │   └── service/impl/
│       │       └── UserServiceImpl.java
│       └── resources/
│           └── application.properties
└── consumer/                        # 服务消费者
    └── src/main/java/
        ├── com/example/
        │   ├── ConsumerApplication.java
        │   └── controller/
        │       └── UserController.java
        └── resources/
            └── application.properties
```

### 6.2 公共模块 - 定义服务接口

**UserService.java**：

```java
package com.example.service;

public interface UserService {
    User getUser(Long id);
    boolean saveUser(User user);
}
```

### 6.3 服务提供者实现

**pom.xml**：

```xml
<dependencies>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-rpc-spring-boot-starter</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.example</groupId>
        <artifactId>common</artifactId>
        <version>1.0.0</version>
    </dependency>
</dependencies>
```

**ProviderApplication.java**：

```java
package com.example;

import com.yupi.yurpc.springboot.starter.annotation.EnableRpc;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@EnableRpc  // 启用 RPC，默认启动服务器
public class ProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProviderApplication.class, args);
    }
}
```

**UserServiceImpl.java**：

```java
package com.example.service.impl;

import com.example.service.UserService;
import com.yupi.yurpc.springboot.starter.annotation.RpcService;
import org.springframework.stereotype.Service;

@Service
@RpcService  // 标记为 RPC 服务，自动注册
public class UserServiceImpl implements UserService {
    
    @Override
    public User getUser(Long id) {
        System.out.println("Provider: 查询用户 " + id);
        User user = new User();
        user.setId(id);
        user.setName("张三");
        return user;
    }

    @Override
    public boolean saveUser(User user) {
        System.out.println("Provider: 保存用户 " + user.getName());
        return true;
    }
}
```

**application.properties**：

```properties
# 应用配置
spring.application.name=rpc-provider
server.port=8081

# RPC 配置
rpc.name=yurpc
rpc.version=2.0
rpc.serverHost=localhost
rpc.serverPort=8080
rpc.serializer=json
rpc.registryConfig.registry=etcd
rpc.registryConfig.address=http://localhost:2380
```

### 6.4 服务消费者实现

**pom.xml**：

```xml
<dependencies>
    <dependency>
        <groupId>com.yupi</groupId>
        <artifactId>yu-rpc-spring-boot-starter</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </dependency>
    <dependency>
        <groupId>com.example</groupId>
        <artifactId>common</artifactId>
        <version>1.0.0</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

**ConsumerApplication.java**：

```java
package com.example;

import com.yupi.yurpc.springboot.starter.annotation.EnableRpc;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@EnableRpc(needServer = false)  // 启用 RPC，不启动服务器
public class ConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class, args);
    }
}
```

**UserController.java**：

```java
package com.example.controller;

import com.example.service.UserService;
import com.yupi.yurpc.springboot.starter.annotation.RpcReference;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/user")
public class UserController {

    // 注入 RPC 服务代理对象
    @RpcReference
    private UserService userService;

    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        // 像调用本地方法一样调用远程服务
        return userService.getUser(id);
    }

    @PostMapping
    public boolean saveUser(@RequestBody User user) {
        return userService.saveUser(user);
    }
}
```

**application.properties**：

```properties
# 应用配置
spring.application.name=rpc-consumer
server.port=8082

# RPC 配置
rpc.name=yurpc
rpc.version=2.0
rpc.registryConfig.registry=etcd
rpc.registryConfig.address=http://localhost:2380
```

### 6.5 运行流程

**1. 启动 Etcd 注册中心**：

```bash
docker run -d --name etcd \
  -p 2379:2379 \
  -p 2380:2380 \
  quay.io/coreos/etcd:latest \
  /usr/local/bin/etcd \
  --listen-client-urls http://0.0.0.0:2379 \
  --advertise-client-urls http://0.0.0.0:2379
```

**2. 启动服务提供者**：

```bash
cd provider
mvn spring-boot:run
```

启动日志：
```
[INFO] RPC 框架初始化完成
[INFO] Vert.x TCP Server started on port 8080
[INFO] 服务注册成功: com.example.service.UserService
```

**3. 启动服务消费者**：

```bash
cd consumer
mvn spring-boot:run
```

启动日志：
```
[INFO] RPC 框架初始化完成
[INFO] 不启动 server
[INFO] 为字段注入代理对象: UserService
```

**4. 测试调用**：

```bash
curl http://localhost:8082/user/1
```

响应：
```json
{
  "id": 1,
  "name": "张三"
}
```

**调用链路**：
```
HTTP 请求 → UserController
    ↓
调用 userService.getUser(1)
    ↓
代理对象拦截调用（ServiceProxy.invoke）
    ↓
从 Etcd 查询服务实例
    ↓
负载均衡选择实例
    ↓
序列化请求（JSON）
    ↓
通过 TCP 发送到 Provider（localhost:8080）
    ↓
Provider 接收请求
    ↓
反序列化请求
    ↓
从 LocalRegistry 获取实现类
    ↓
反射调用 UserServiceImpl.getUser(1)
    ↓
序列化响应
    ↓
通过 TCP 返回给 Consumer
    ↓
反序列化响应
    ↓
返回结果给 Controller
    ↓
HTTP 响应
```


## 七、高级特性

### 7.1 服务版本控制

**场景**：同一个服务接口有多个版本，需要灰度发布或兼容旧版本。

**Provider 端**：

```java
// 旧版本
@Service
@RpcService(serviceVersion = "1.0")
public class UserServiceV1Impl implements UserService {
    @Override
    public User getUser(Long id) {
        // 旧逻辑
        return new User(id, "旧版本用户");
    }
}

// 新版本
@Service
@RpcService(serviceVersion = "2.0")
public class UserServiceV2Impl implements UserService {
    @Override
    public User getUser(Long id) {
        // 新逻辑，增加了缓存
        return cacheManager.getOrLoad(id);
    }
}
```

**Consumer 端**：

```java
@Service
public class UserController {
    // 调用旧版本
    @RpcReference(serviceVersion = "1.0")
    private UserService userServiceV1;

    // 调用新版本
    @RpcReference(serviceVersion = "2.0")
    private UserService userServiceV2;

    public User getUser(Long id, boolean useNewVersion) {
        return useNewVersion ? 
            userServiceV2.getUser(id) : 
            userServiceV1.getUser(id);
    }
}
```

### 7.2 负载均衡策略

**轮询（默认）**：

```java
@RpcReference(loadBalancer = LoadBalancerKeys.ROUND_ROBIN)
private UserService userService;
```

**随机**：

```java
@RpcReference(loadBalancer = LoadBalancerKeys.RANDOM)
private UserService userService;
```

**一致性哈希**（适合有状态服务）：

```java
@RpcReference(loadBalancer = LoadBalancerKeys.CONSISTENT_HASH)
private UserService userService;
```

### 7.3 重试策略

**无重试（默认）**：

```java
@RpcReference(retryStrategy = RetryStrategyKeys.NO)
private UserService userService;
```

**固定间隔重试**：

```java
@RpcReference(
    retryStrategy = RetryStrategyKeys.FIXED_INTERVAL,
    tolerantStrategy = TolerantStrategyKeys.FAIL_OVER
)
private UserService userService;
```

配置文件中设置重试参数：

```properties
# 重试次数
rpc.retryStrategy=fixedInterval
rpc.retryConfig.maxAttempts=3
rpc.retryConfig.waitTime=2000
```

### 7.4 容错策略

**快速失败（默认）**：

```java
@RpcReference(tolerantStrategy = TolerantStrategyKeys.FAIL_FAST)
private UserService userService;
// 调用失败立即抛出异常
```

**静默失败**：

```java
@RpcReference(tolerantStrategy = TolerantStrategyKeys.FAIL_SAFE)
private UserService userService;
// 调用失败返回 null，不抛出异常
```

**故障转移**：

```java
@RpcReference(
    tolerantStrategy = TolerantStrategyKeys.FAIL_OVER,
    retryStrategy = RetryStrategyKeys.FIXED_INTERVAL
)
private UserService userService;
// 调用失败自动切换到其他服务实例重试
```

**故障恢复**：

```java
@RpcReference(tolerantStrategy = TolerantStrategyKeys.FAIL_BACK)
private UserService userService;
// 调用失败后台异步重试，立即返回空结果
```

### 7.5 Mock 模式

**场景**：开发阶段服务提供者未就绪，使用 Mock 数据进行开发。

**启用 Mock**：

```java
@RpcReference(mock = true)
private UserService userService;
```

**Mock 实现**（yu-rpc-core）：

```java
public class MockServiceProxy implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) {
        Class<?> returnType = method.getReturnType();
        // 根据返回类型生成默认值
        if (returnType.isPrimitive()) {
            return getDefaultPrimitiveValue(returnType);
        }
        return null;
    }
}
```

### 7.6 多注册中心支持

**Etcd**：

```properties
rpc.registryConfig.registry=etcd
rpc.registryConfig.address=http://localhost:2380
```

**ZooKeeper**：

```properties
rpc.registryConfig.registry=zookeeper
rpc.registryConfig.address=localhost:2181
```

## 八、设计优势

### 8.1 对比传统编程式 API

**传统方式**（example-provider/consumer）：

```java
// Provider 端
public class ProviderExample {
    public static void main(String[] args) {
        // 1. 手动初始化框架
        RpcApplication.init();

        // 2. 手动注册服务
        LocalRegistry.register(UserService.class.getName(), UserServiceImpl.class);

        // 3. 手动注册到注册中心
        RegistryConfig registryConfig = RpcApplication.getRpcConfig().getRegistryConfig();
        Registry registry = RegistryFactory.getInstance(registryConfig.getRegistry());
        ServiceMetaInfo serviceMetaInfo = new ServiceMetaInfo();
        serviceMetaInfo.setServiceName(UserService.class.getName());
        serviceMetaInfo.setServiceHost("localhost");
        serviceMetaInfo.setServicePort(8080);
        registry.register(serviceMetaInfo);

        // 4. 手动启动服务器
        VertxTcpServer server = new VertxTcpServer();
        server.doStart(8080);
    }
}

// Consumer 端
public class ConsumerExample {
    public static void main(String[] args) {
        // 1. 手动初始化框架
        RpcApplication.init();

        // 2. 手动创建代理对象
        UserService userService = ServiceProxyFactory.getProxy(UserService.class);

        // 3. 调用服务
        User user = userService.getUser(1L);
    }
}
```

**注解驱动方式**：

```java
// Provider 端
@SpringBootApplication
@EnableRpc
public class ProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProviderApplication.class, args);
    }
}

@Service
@RpcService
public class UserServiceImpl implements UserService {
    // 业务逻辑
}

// Consumer 端
@SpringBootApplication
@EnableRpc(needServer = false)
public class ConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class, args);
    }
}

@RestController
public class UserController {
    @RpcReference
    private UserService userService;
    
    // 业务逻辑
}
```

**对比总结**：

| 特性 | 传统编程式 | 注解驱动 |
|------|-----------|---------|
| 代码量 | 大量样板代码 | 极简，只需注解 |
| 配置方式 | 硬编码 | 配置文件 + 注解 |
| Spring 集成 | 需要手动集成 | 自动集成 |
| 依赖注入 | 手动管理 | Spring 自动注入 |
| 生命周期管理 | 手动管理 | Spring 自动管理 |
| 学习成本 | 需要了解框架 API | 只需了解注解 |

### 8.2 核心优势

1. **声明式编程**：
   - 通过注解声明意图，框架自动完成实现
   - 代码简洁，可读性强

2. **Spring 生态集成**：
   - 利用 Spring 的依赖注入、生命周期管理
   - 与 Spring Boot、Spring Cloud 无缝集成

3. **零侵入**：
   - 业务代码不依赖 RPC 框架 API
   - 服务接口定义在公共模块，无框架依赖

4. **灵活配置**：
   - 支持注解参数配置（细粒度）
   - 支持配置文件配置（全局）
   - 注解参数优先级高于配置文件

5. **自动化**：
   - 自动服务注册和发现
   - 自动代理对象创建和注入
   - 自动服务器启动和关闭

## 九、最佳实践

### 9.1 模块划分

```
project/
├── common/          # 服务接口定义，无框架依赖
├── provider/        # 服务提供者，依赖 starter
└── consumer/        # 服务消费者，依赖 starter
```

### 9.2 接口设计

```java
// ✅ 推荐：接口参数和返回值使用 POJO
public interface UserService {
    UserDTO getUser(Long id);
    boolean saveUser(UserDTO user);
}

// ❌ 不推荐：使用复杂类型（如 HttpServletRequest）
public interface UserService {
    User getUser(HttpServletRequest request);  // 无法序列化
}
```

### 9.3 异常处理

```java
@RestController
public class UserController {
    @RpcReference
    private UserService userService;

    @GetMapping("/user/{id}")
    public Result<User> getUser(@PathVariable Long id) {
        try {
            User user = userService.getUser(id);
            return Result.success(user);
        } catch (Exception e) {
            log.error("RPC 调用失败", e);
            return Result.error("服务暂时不可用");
        }
    }
}
```

### 9.4 配置管理

**开发环境**（application-dev.properties）：

```properties
rpc.mock=true  # 启用 Mock
rpc.registryConfig.registry=etcd
rpc.registryConfig.address=http://localhost:2380
```

**生产环境**（application-prod.properties）：

```properties
rpc.mock=false
rpc.registryConfig.registry=etcd
rpc.registryConfig.address=http://etcd-cluster:2380
rpc.loadBalancer=consistentHash
rpc.retryStrategy=fixedInterval
rpc.tolerantStrategy=failOver
```

### 9.5 监控和日志

```java
@Slf4j
@Service
@RpcService
public class UserServiceImpl implements UserService {
    @Override
    public User getUser(Long id) {
        log.info("RPC 请求: getUser, id={}", id);
        long startTime = System.currentTimeMillis();
        try {
            User user = userRepository.findById(id);
            log.info("RPC 响应: getUser, cost={}ms", 
                System.currentTimeMillis() - startTime);
            return user;
        } catch (Exception e) {
            log.error("RPC 异常: getUser, id={}", id, e);
            throw e;
        }
    }
}
```

## 十、总结

Yu-RPC Spring Boot Starter 通过注解驱动的设计，将复杂的 RPC 框架集成简化为几个注解的使用。核心设计包括：

1. **三大注解**：`@EnableRpc`、`@RpcService`、`@RpcReference`
2. **三大 Bootstrap**：`RpcInitBootstrap`、`RpcProviderBootstrap`、`RpcConsumerBootstrap`
3. **两大扩展点**：`ImportBeanDefinitionRegistrar`、`BeanPostProcessor`

通过这套设计，开发者可以像使用 Spring Bean 一样使用 RPC 服务，极大降低了分布式系统开发的复杂度。

face UserService {
    User getUser(Long id);  // ✅ 使用 POJO
}

// ❌ 不推荐：使用基本类型和多参数
public interface UserService {
    String getUserName(long id, String type, boolean detail);
}
```

### 9.3 异常处理

```java
@RestController
public class UserController {
    @RpcReference
    private UserService userService;

    @GetMapping("/user/{id}")
    public Result<User> getUser(@PathVariable Long id) {
        try {
            User user = userService.getUser(id);
            return Result.success(user);
        } catch (Exception e) {
            log.error("RPC 调用失败", e);
            return Result.error("服务暂时不可用");
        }
    }
}
```

### 9.4 配置管理

**开发环境**（application-dev.properties）：

```properties
rpc.mock=true  # 启用 Mock
rpc.registryConfig.registry=etcd
rpc.registryConfig.address=http://localhost:2380
```

**生产环境**（application-prod.properties）：

```properties
rpc.mock=false
rpc.registryConfig.registry=etcd
rpc.registryConfig.address=http://etcd-cluster:2380
rpc.loadBalancer=consistentHash
rpc.retryStrategy=fixedInterval
rpc.tolerantStrategy=failOver
```

### 9.5 服务治理

**服务分组**：

```java
// 核心服务：高可用配置
@RpcReference(
    loadBalancer = LoadBalancerKeys.CONSISTENT_HASH,
    retryStrategy = RetryStrategyKeys.FIXED_INTERVAL,
    tolerantStrategy = TolerantStrategyKeys.FAIL_OVER
)
private OrderService orderService;

// 非核心服务：快速失败
@RpcReference(
    retryStrategy = RetryStrategyKeys.NO,
    tolerantStrategy = TolerantStrategyKeys.FAIL_FAST
)
private RecommendService recommendService;
```

## 十、常见问题

### 10.1 服务注册失败

**问题**：启动时报错 "服务注册失败"

**原因**：
- 注册中心未启动
- 注册中心地址配置错误
- 网络不通

**解决**：
```bash
# 检查 Etcd 是否启动
docker ps | grep etcd

# 测试连接
curl http://localhost:2379/version

# 检查配置
rpc.registryConfig.address=http://localhost:2380  # 注意端口
```

### 10.2 代理对象注入失败

**问题**：`@RpcReference` 字段为 null

**原因**：
- 未添加 `@EnableRpc` 注解
- 字段所在类不是 Spring Bean
- 接口类型配置错误

**解决**：
```java
// ✅ 确保类是 Spring Bean
@Service  // 或 @Component、@Controller
public class UserController {
    @RpcReference
    private UserService userService;
}

// ✅ 确保启动类有 @EnableRpc
@SpringBootApplication
@EnableRpc
public class Application {
    // ...
}
```

### 10.3 服务调用超时

**问题**：调用远程服务时超时

**原因**：
- 服务提供者未启动
- 网络延迟
- 服务处理时间过长

**解决**：
```properties
# 增加超时时间
rpc.timeout=10000

# 启用重试
rpc.retryStrategy=fixedInterval
rpc.retryConfig.maxAttempts=3
```

### 10.4 序列化失败

**问题**：调用时报 "序列化失败"

**原因**：
- POJO 类未实现 Serializable
- 使用了不支持的类型（如 Lambda）
- 序列化器配置不一致

**解决**：
```java
// ✅ POJO 实现 Serializable
public class User implements Serializable {
    private static final long serialVersionUID = 1L;
    private Long id;
    private String name;
}

// ✅ 确保 Provider 和 Consumer 使用相同序列化器
rpc.serializer=json  # 两端配置一致
```

## 十一、总结

Yu-RPC Spring Boot Starter 通过注解驱动的设计，实现了 RPC 框架与 Spring Boot 的深度集成：

1. **三大核心注解**：
   - `@EnableRpc`：启用框架
   - `@RpcService`：发布服务
   - `@RpcReference`：消费服务

2. **三大 Bootstrap**：
   - `RpcInitBootstrap`：框架初始化
   - `RpcProviderBootstrap`：服务注册
   - `RpcConsumerBootstrap`：代理注入

3. **核心机制**：
   - 利用 Spring 的 `@Import` 机制导入配置
   - 利用 `ImportBeanDefinitionRegistrar` 在容器启动时初始化
   - 利用 `BeanPostProcessor` 在 Bean 创建后处理注解
   - 利用 JDK 动态代理实现透明的远程调用

4. **设计优势**：
   - 声明式编程，代码简洁
   - 与 Spring 生态无缝集成
   - 对业务代码零侵入
   - 支持丰富的配置和扩展

这种设计使得开发者可以像使用 Spring 的 `@Autowired` 一样简单地使用 RPC 服务，极大地降低了分布式系统开发的复杂度。

