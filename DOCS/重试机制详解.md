# Yu-RPC 重试机制详解

## 一、概述

重试机制是 RPC 框架中提高服务可用性和容错能力的重要组件。在分布式环境中，网络抖动、服务暂时不可用等临时性故障时有发生，通过合理的重试策略可以有效提升请求成功率，避免因偶发性故障导致的业务失败。

Yu-RPC 框架采用**策略模式 + SPI 机制**实现了灵活可扩展的重试机制，支持多种重试策略，并可通过配置文件动态切换。

## 二、整体架构

### 2.1 核心组件

重试机制由以下核心组件构成：

```
fault.retry/
├── RetryStrategy.java              # 重试策略接口
├── RetryStrategyKeys.java          # 重试策略键名常量
├── RetryStrategyFactory.java       # 重试策略工厂
├── NoRetryStrategy.java            # 不重试策略实现
└── FixedIntervalRetryStrategy.java # 固定间隔重试策略实现
```

### 2.2 设计模式

1. **策略模式（Strategy Pattern）**：定义统一的重试策略接口，不同的重试算法实现该接口
2. **工厂模式（Factory Pattern）**：通过工厂类统一管理和创建重试策略实例
3. **SPI 机制（Service Provider Interface）**：实现重试策略的可插拔，支持自定义扩展

## 三、核心接口设计

### 3.1 RetryStrategy 接口

```java
public interface RetryStrategy {
    /**
     * 重试
     *
     * @param callable 待执行的任务（RPC 请求）
     * @return RPC 响应结果
     * @throws Exception 重试失败后抛出异常
     */
    RpcResponse doRetry(Callable<RpcResponse> callable) throws Exception;
}
```

**设计要点**：
- 使用 `Callable<RpcResponse>` 作为参数，将具体的 RPC 请求逻辑封装为可调用任务
- 返回 `RpcResponse` 统一响应类型
- 抛出 `Exception` 供上层容错机制处理

### 3.2 RetryStrategyKeys 常量类

```java
public interface RetryStrategyKeys {
    String NO = "no";                          // 不重试
    String FIXED_INTERVAL = "fixedInterval";   // 固定时间间隔
}
```

**设计要点**：
- 定义重试策略的键名常量，用于配置文件和 SPI 加载
- 便于统一管理和避免硬编码

## 四、重试策略实现

### 4.1 NoRetryStrategy - 不重试策略

**实现代码**：
```java
@Slf4j
public class NoRetryStrategy implements RetryStrategy {
    public RpcResponse doRetry(Callable<RpcResponse> callable) throws Exception {
        return callable.call();
    }
}
```

**特点**：
- 直接执行一次任务，不进行任何重试
- 适用于对实时性要求高、不允许延迟的场景
- 作为框架的默认重试策略（`RpcConfig` 中默认配置）

### 4.2 FixedIntervalRetryStrategy - 固定间隔重试策略

**实现代码**：
```java
@Slf4j
public class FixedIntervalRetryStrategy implements RetryStrategy {
    public RpcResponse doRetry(Callable<RpcResponse> callable)
            throws ExecutionException, RetryException {
        Retryer<RpcResponse> retryer = RetryerBuilder.<RpcResponse>newBuilder()
                .retryIfExceptionOfType(Exception.class)           // 遇到任何异常都重试
                .withWaitStrategy(WaitStrategies.fixedWait(3L, TimeUnit.SECONDS))  // 固定等待 3 秒
                .withStopStrategy(StopStrategies.stopAfterAttempt(3))              // 最多重试 3 次
                .withRetryListener(new RetryListener() {
                    @Override
                    public <V> void onRetry(Attempt<V> attempt) {
                        log.info("重试次数 {}", attempt.getAttemptNumber());
                    }
                })
                .build();
        return retryer.call(callable);
    }
}
```

**技术选型**：
- 使用 **Guava Retrying** 库（`com.github.rholder:guava-retrying:2.0.0`）
- Guava Retrying 提供了丰富的重试策略配置和监听机制

**配置参数**：
- **重试条件**：`retryIfExceptionOfType(Exception.class)` - 任何异常都触发重试
- **等待策略**：`fixedWait(3L, TimeUnit.SECONDS)` - 每次重试间隔固定 3 秒
- **停止策略**：`stopAfterAttempt(3)` - 最多尝试 3 次（包括首次调用）
- **监听器**：记录每次重试的次数，便于调试和监控

**适用场景**：
- 网络抖动、服务暂时不可用等临时性故障
- 对延迟容忍度较高的业务场景
- 需要给服务端恢复时间的场景

## 五、工厂类与 SPI 加载

### 5.1 RetryStrategyFactory 工厂类

```java
public class RetryStrategyFactory {
    static {
        SpiLoader.load(RetryStrategy.class);  // 静态代码块加载 SPI
    }

    private static final RetryStrategy DEFAULT_RETRY_STRATEGY = new NoRetryStrategy();

    public static RetryStrategy getInstance(String key) {
        return SpiLoader.getInstance(RetryStrategy.class, key);
    }
}
```

**设计要点**：
- 静态代码块在类加载时自动加载所有 `RetryStrategy` 的 SPI 实现
- 提供默认重试策略（不重试）
- 通过 `key` 获取对应的重试策略实例

### 5.2 SPI 配置文件

**文件路径**：`yu-rpc-core/src/main/resources/META-INF/rpc/system/com.yupi.yurpc.fault.retry.RetryStrategy`

**文件内容**：
```properties
no=com.yupi.yurpc.fault.retry.NoRetryStrategy
fixedInterval=com.yupi.yurpc.fault.retry.FixedIntervalRetryStrategy
```

**SPI 机制优势**：
- 实现重试策略的可插拔，无需修改核心代码
- 支持用户自定义重试策略（在 `META-INF/rpc/custom/` 目录下配置）
- 延迟加载，按需创建实例

## 六、配置与使用

### 6.1 全局配置

在 `RpcConfig` 中定义重试策略配置项：

```java
@Data
public class RpcConfig {
    /**
     * 重试策略
     */
    private String retryStrategy = RetryStrategyKeys.NO;  // 默认不重试

    // ... 其他配置
}
```

### 6.2 配置文件

在 `application.properties` 或 `application.yml` 中配置：

```properties
# 不重试（默认）
rpc.retryStrategy=no

# 固定间隔重试
rpc.retryStrategy=fixedInterval
```

### 6.3 在代理层使用

重试机制在 `ServiceProxy` 的 `invoke` 方法中被调用（`ServiceProxy.java:82-87`）：

```java
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    // ... 构造请求、服务发现、负载均衡 ...

    RpcResponse rpcResponse;
    try {
        // 获取配置的重试策略
        RetryStrategy retryStrategy = RetryStrategyFactory.getInstance(rpcConfig.getRetryStrategy());

        // 使用重试策略包装 RPC 请求
        rpcResponse = retryStrategy.doRetry(() ->
                VertxTcpClient.doRequest(rpcRequest, selectedServiceMetaInfo)
        );
    } catch (Exception e) {
        // 重试失败后触发容错机制
        TolerantStrategy tolerantStrategy = TolerantStrategyFactory.getInstance(rpcConfig.getTolerantStrategy());
        rpcResponse = tolerantStrategy.doTolerant(null, e);
    }

    return rpcResponse.getData();
}
```

**执行流程**：
1. 根据配置获取重试策略实例
2. 将 `VertxTcpClient.doRequest()` 封装为 `Callable` 传入重试策略
3. 重试策略执行任务，根据配置决定是否重试
4. 如果重试全部失败，抛出异常由容错机制处理

## 七、重试机制与容错机制的协作

重试机制和容错机制是 RPC 框架中两个互补的容错手段：

```
RPC 请求 → 重试机制 → 成功返回
                ↓ 失败
           容错机制 → 降级处理
```

**协作流程**：
1. **重试机制**：处理临时性、可恢复的故障（网络抖动、服务暂时不可用）
2. **容错机制**：处理持久性、不可恢复的故障（服务宕机、超时）

**代码体现**（`ServiceProxy.java:81-92`）：
```java
try {
    // 先尝试重试
    rpcResponse = retryStrategy.doRetry(() -> VertxTcpClient.doRequest(...));
} catch (Exception e) {
    // 重试失败后启动容错
    rpcResponse = tolerantStrategy.doTolerant(null, e);
}
```

## 八、扩展指南

### 8.1 自定义重试策略

**步骤 1**：实现 `RetryStrategy` 接口

```java
public class ExponentialBackoffRetryStrategy implements RetryStrategy {
    @Override
    public RpcResponse doRetry(Callable<RpcResponse> callable) throws Exception {
        Retryer<RpcResponse> retryer = RetryerBuilder.<RpcResponse>newBuilder()
                .retryIfExceptionOfType(Exception.class)
                .withWaitStrategy(WaitStrategies.exponentialWait(1000, 30, TimeUnit.SECONDS))  // 指数退避
                .withStopStrategy(StopStrategies.stopAfterAttempt(5))
                .build();
        return retryer.call(callable);
    }
}
```

**步骤 2**：在 SPI 配置文件中注册

创建文件：`META-INF/rpc/custom/com.yupi.yurpc.fault.retry.RetryStrategy`

```properties
exponentialBackoff=com.yourpackage.ExponentialBackoffRetryStrategy
```

**步骤 3**：在配置文件中使用

```properties
rpc.retryStrategy=exponentialBackoff
```

### 8.2 常见重试策略扩展

可以基于 Guava Retrying 实现更多重试策略：

1. **指数退避重试**：`WaitStrategies.exponentialWait()` - 重试间隔指数增长
2. **随机间隔重试**：`WaitStrategies.randomWait()` - 随机等待时间
3. **限时重试**：`StopStrategies.stopAfterDelay()` - 在指定时间内重试
4. **条件重试**：`retryIfResult()` - 根据返回结果决定是否重试

重试机制
我们可能更希望服务消费者拥有自动重试的能力，提高系统的可用性。
我了解到的几种重试策略：
1. 指数退避重试：在每次失败后，重试的时间间隔会以指数级增加，以避免请求过于密集。
2. 随机延迟重试：在每次重试之间使用随机的时间间隔，以避免请求的同时发生。
   100个都失败了 100个都在T0+1同时重试 再次崩溃  RetryStrategy: 失败后等待 [0.5秒 ~ 1.5秒] 随机时间重试
3. 可变延迟重试：这种策略更 “高级” 了，根据先前重试的成功或失败情况，动态调整下一次重试的延迟时间。比如，根据前一次的响应时间调整下一次重试的等待时间。
   根据系统的实际运行状态（响应时间、成功率、错误类型等），动态调整重试延迟时间。
   值得一提的是，以上的策略是可以组合使用的，一定要根据具体情况和需求灵活调整。比如可以先使用指数退避重试策略，如果连续多次重试失败，则切换到固定重试间隔策略。

## 九、测试验证

### 9.1 单元测试

测试代码位于 `RetryStrategyTest.java`：

```java
public class RetryStrategyTest {
    RetryStrategy retryStrategy = new FixedIntervalRetryStrategy();

    @Test
    public void doRetry() {
        try {
            RpcResponse rpcResponse = retryStrategy.doRetry(() -> {
                System.out.println("测试重试");
                throw new RuntimeException("模拟重试失败");
            });
            System.out.println(rpcResponse);
        } catch (Exception e) {
            System.out.println("重试多次失败");
            e.printStackTrace();
        }
    }
}
```

**测试输出**（使用 `FixedIntervalRetryStrategy`）：
```
测试重试
重试次数 1
测试重试
重试次数 2
测试重试
重试次数 3
重试多次失败
```

### 9.2 集成测试

在实际 RPC 调用中测试重试机制：

1. 启动服务提供者
2. 配置消费者使用固定间隔重试策略
3. 模拟网络故障或服务暂停
4. 观察重试日志和最终结果

## 十、性能与注意事项

### 10.1 性能影响

- **延迟增加**：重试会增加请求的总延迟时间（重试次数 × 等待间隔）
- **资源占用**：重试期间会占用线程和网络资源
- **服务端压力**：大量重试可能加重服务端负载

### 10.2 最佳实践

1. **合理设置重试次数**：建议 2-3 次，避免过多重试
2. **选择合适的等待策略**：
   - 固定间隔：适用于网络抖动
   - 指数退避：适用于服务恢复需要时间的场景
3. **区分可重试和不可重试的异常**：
   - 可重试：网络超时、连接失败、服务暂时不可用
   - 不可重试：参数错误、权限不足、业务逻辑错误
4. **配合熔断器使用**：避免对已知故障的服务进行无效重试
5. **监控重试指标**：记录重试次数、成功率，及时发现系统问题

### 10.3 注意事项

1. **幂等性要求**：重试机制要求 RPC 方法具有幂等性，避免重复执行产生副作用
2. **超时时间设置**：总超时时间应考虑重试次数和间隔
3. **日志记录**：记录每次重试的详细信息，便于问题排查
4. **避免重试风暴**：在分布式系统中，大量客户端同时重试可能导致雪崩

## 十一、总结

Yu-RPC 的重试机制设计具有以下特点：

1. **架构清晰**：策略模式 + SPI 机制，职责分离，易于扩展
2. **配置灵活**：支持通过配置文件动态切换重试策略
3. **技术成熟**：基于 Guava Retrying 库，功能强大且稳定
4. **协作良好**：与容错机制配合，形成完整的容错体系
5. **易于扩展**：通过 SPI 机制可轻松添加自定义重试策略

重试机制是提升 RPC 框架可靠性的重要手段，合理使用可以有效应对分布式环境中的各种临时性故障，提升系统的整体可用性。
